<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>class类文件结构（这是一篇非常枯燥的文章）</title>
    <url>/2020/06/20/class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%88%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E9%9D%9E%E5%B8%B8%E6%9E%AF%E7%87%A5%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<p>我们知道，Java文件编译后会产生一个字节码文件（<code>.class</code>文件），本文介绍字节码文件的文件结构相关内容。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java诞生之初就宣称的“一次编译，处处运行”的性质一直是Java的一大特点，而Java实现这个特点的方式是将<code>.java</code>文件编译成<code>.class</code>文件，通过JVM屏蔽系统差异实现的。事实上，不仅是Java，其他的比如Kotlin、Groovy等语言也都可以通过编译成字节码文件运行在Java虚拟机上，而Java虚拟机也并不关心被编译成字节码文件之前是什么语言。</p>
<p><img src="https://img-blog.csdnimg.cn/20200620163721654.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="不同语言的编译与加载"></p>
<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>按照Java虚拟机规范，class文件结构一般是向后兼容的，新版本的Java虚拟机规范一般只是在旧版基础上进行扩充，而不对之前内容修改，因此类文件结构从第一版开始定义的一些细节几乎没有变化。我们先来看一下class文件格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; &#x2F;&#x2F;Class 文件的标志：魔数</span><br><span class="line">    u2             minor_version;&#x2F;&#x2F;Class 的次版本号</span><br><span class="line">    u2             major_version;&#x2F;&#x2F;Class 的主版本号</span><br><span class="line">    u2             constant_pool_count;&#x2F;&#x2F;常量池的数量</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];&#x2F;&#x2F;常量池</span><br><span class="line">    u2             access_flags;&#x2F;&#x2F;Class 的访问标志</span><br><span class="line">    u2             this_class;&#x2F;&#x2F;当前类</span><br><span class="line">    u2             super_class;&#x2F;&#x2F;父类</span><br><span class="line">    u2             interfaces_count;&#x2F;&#x2F;接口</span><br><span class="line">    u2             interfaces[interfaces_count];&#x2F;&#x2F;一个类可以实现多个接口</span><br><span class="line">    u2             fields_count;&#x2F;&#x2F;Class 文件的字段属性</span><br><span class="line">    field_info     fields[fields_count];&#x2F;&#x2F;一个类会可以有个字段</span><br><span class="line">    u2             methods_count;&#x2F;&#x2F;Class 文件的方法数量</span><br><span class="line">    method_info    methods[methods_count];&#x2F;&#x2F;一个类可以有个多个方法</span><br><span class="line">    u2             attributes_count;&#x2F;&#x2F;此类的属性表中的属性数</span><br><span class="line">    attribute_info attributes[attributes_count];&#x2F;&#x2F;属性表集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>u2</code>和<code>u4</code>分别代表两个字节和四个字节的无符号数，<code>_info</code>结尾表示是一个表结构，表结构可以理解为一个类，用于表示复合数据结构的数据。</p>
<p><img src="https://img-blog.csdnimg.cn/20200620164845561.png?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="class文件字节码结构组织示意图"></p>
<p>上图是class文件字节码结构组织示意图，结构非常清楚。接下来为大家依次介绍class文件结构的各个部分。</p>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u4             magic; &#x2F;&#x2F;Class 文件的标志：魔数</span><br></pre></td></tr></table></figure>

<p>字节码文件前4个字节被称为魔数（magic number），作用是让JVM能够识别这是一个字节码文件。其实不仅是字节码文件，一些图片的格式也存在魔数。字节码文件的魔数比较可爱，它的值为0xcafebabe（咖啡宝贝）。</p>
<h3 id="Class文件版本"><a href="#Class文件版本" class="headerlink" title="Class文件版本"></a>Class文件版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u2             minor_version;&#x2F;&#x2F;Class 的次版本号</span><br><span class="line">u2             major_version;&#x2F;&#x2F;Class 的主版本号</span><br></pre></td></tr></table></figure>

<p>跟在魔数后面的四个字节表示Class文件的版本号，前两个字节是次版本号，后两个字节是主版本号。高版本的JDK可以支持低版本的Class文件，而低版本的JDK无法支持高版本为Class文件。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u2             constant_pool_count;&#x2F;&#x2F;常量池的数量</span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];&#x2F;&#x2F;常量池</span><br></pre></td></tr></table></figure>

<p><code>constant_pool_count</code>被用来表示常量池的常量数，这里的常量池是从1开始索引的，因为第0项是用于某些指向常量池的索引值的数据在特定情况下表示“不引用任何一个常量池项目”的含义。</p>
<p>常量池中存放两种类型的常量：字面量和符号引用。前者很接近Java语言对于常量的定义（字符串、被final修饰的常量等），后者则倾向于编译原理方面，主要包括：</p>
<ul>
<li><p>被模块导出或者开放的包（Package）</p>
</li>
<li><p>类和接口的全限定名（Fully Qualified Name）</p>
</li>
<li><p>字段的名称和描述符（Descriptor）</p>
</li>
<li><p>方法的名称和描述符</p>
</li>
<li><p>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</p>
</li>
<li><p>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-ComputedConstant）</p>
</li>
</ul>
<p>常量池的每一个常量都是一个表，表结构起始的第一位是个u1类型的标志位（tag），代表着当前常量属于哪种常量类型。常见常量类型所代表的具体含义如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志（tag）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整形字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">５</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">６</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">７</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">８</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Fieldref_info</td>
<td align="center">９</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_Methodref_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodref_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MothodType_info</td>
<td align="center">16</td>
<td align="center">标志方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">表示方法句柄</td>
</tr>
<tr>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">18</td>
<td align="center">表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u2             access_flags;&#x2F;&#x2F;Class 的访问标志</span><br></pre></td></tr></table></figure>

<p>访问标志的部分比较简单，主要用来标记类或接口的访问信息，是类还是接口，是否是public类型，是否定义为final，是否是abstract类型等。</p>
<p><img src="https://img-blog.csdnimg.cn/20200621160212261.jpg#pic_center" alt="访问标志"></p>
<p>定义一个普通的用public修饰的Java类，并且用JDK1.2以后的编译器编译，那么除了<code>ACC_PUBLIC</code>和<code>ACC_SUPER</code>为真，其它全为假。</p>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u2             this_class;&#x2F;&#x2F;当前类</span><br><span class="line">u2             super_class;&#x2F;&#x2F;父类</span><br><span class="line">u2             interfaces_count;&#x2F;&#x2F;接口</span><br><span class="line">u2             interfaces[interfaces_count];&#x2F;&#x2F;一个类可以实现多个接口</span><br></pre></td></tr></table></figure>

<p>类索引和父类索引分别用来确定当前类和父类的全限定名，所谓全限定名就是类的路径全名，例如String类的全限定名是<code>java/lang/String</code>。由于除了Object类以外的所有类都有父类，所以只有Object类的父类索引为0。接口索引集合定义了类实现了哪些接口。</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u2             fields_count;&#x2F;&#x2F;Class 文件的字段属性</span><br><span class="line">field_info     fields[fields_count];&#x2F;&#x2F;一个类会可以有个字段</span><br></pre></td></tr></table></figure>

<p>字段表用来描述类/接口中的成员变量，不是描述方法中的局部变量。下面是field_info的结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20200621171938535.png#pic_center" alt="field_info结构"></p>
<p><code>access_flag</code>是用于确定字段的访问修饰符、是否静态变量、是否可变（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。下面是<code>access_flag</code>的取值：</p>
<p><img src="https://img-blog.csdnimg.cn/2020062117414847.png#pic_center" alt="access_flag的取值"></p>
<p><code>name_index</code>是对常量池的引用，用于描述字段的名称。</p>
<p><code>descriptor_index</code>也是对常量池的引用，是字段和方法的描述符。</p>
<p><code>attributes_count</code>和<code>attributes[attributes_count]</code>是用于存放字段的一些属性。</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u2             methods_count;&#x2F;&#x2F;Class 文件的方法数量</span><br><span class="line">method_info    methods[methods_count];&#x2F;&#x2F;一个类可以有个多个方法</span><br></pre></td></tr></table></figure>

<p>方法表用来描述类中的方法，<code>method_info</code>结构和<code>field_info</code>几乎一样，这里就不过多介绍了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200621193212215.png#pic_center" alt="方法表的结构"></p>
<p>下面是方法表的<code>access_flag</code>取值：</p>
<p><img src="https://img-blog.csdnimg.cn/20200621214831583.png#pic_center" alt="方法表的access_flag的所有标志位"></p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u2             attributes_count;&#x2F;&#x2F;此类的属性表中的属性数</span><br><span class="line">attribute_info attributes[attributes_count];&#x2F;&#x2F;属性表集合</span><br></pre></td></tr></table></figure>

<p>属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p>
<p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>一道广联达秋招算法题</title>
    <url>/2020/07/22/%E4%B8%80%E9%81%93%E5%B9%BF%E8%81%94%E8%BE%BE%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p>今天下午师兄在教研室群里发了一道热乎的广联达算法题，乍一看完全没有思路，于是实验室的小伙伴们饶有兴致地开始讨论起了这道题。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200722183430700.jpg#pic_center" alt=""></p>
<p>先给大家看一下题目：</p>
<p><strong>题目描述</strong></p>
<p>有一种排序算法定义如下，该排序算法每次把一个元素提到序列的开头，例如<code>2, 1, 3, 4</code>，只需要一次操作把1提到序列起始位置就可以使得原序列从小到大有序。<br>现在给你个乱序的1-n的排列，请你计算最少需要多少次操作才可以使得原序列从小到大有序。</p>
<p><strong>输入描述</strong></p>
<blockquote>
<p>输入第一行包含两个正整数n，表示序列的长度。（1 &lt;= n &lt;= 100000）<br>接下来一行有n个正整数，表示序列中的n个元素，中间用空格隔开。<br>（1 &lt;= a_i &lt;= n）</p>
</blockquote>
<p><strong>输出描述</strong></p>
<blockquote>
<p>输出仅包含一个整数，表示最少的操作次数。</p>
</blockquote>
<p><strong>样例输入</strong></p>
<blockquote>
<p>4<br>2 1 3 4</p>
</blockquote>
<p><strong>样例输出</strong></p>
<blockquote>
<p>1</p>
</blockquote>
<p>以上就是这道题的题干，说实话，第一眼看过去我甚至觉得这是到冒泡排序。但仔细一看，每个数必须要移动到序列起始位置。</p>
<p><img src="https://img-blog.csdnimg.cn/20200722184639739.jpg#pic_center" alt=""></p>
<p>忽然，一个想法闪过我的脑海。</p>
<p><img src="https://img-blog.csdnimg.cn/20200722184804203.jpg#pic_center" alt=""></p>
<p>我是这样想的：<strong>当一个数被移动到序列的起始位置，那么意味着所有比它小的数都要移动到起始位置。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200722185437367.jpg#pic_center" alt=""></p>
<p>举个栗子，我们看一下下面一组序列。</p>
<blockquote>
<p>2 5 3 1 4 6 7 8</p>
</blockquote>
<p>直观地看，我们首先需要把4移到最前面，再把3移到最前面，接着是2和1两个数移到最前面。</p>
<p><img src="https://img-blog.csdnimg.cn/20200722190400128.png#pic_center" alt=""></p>
<p>看到这里，大家应该看明白了。我们需要与排序后的数组对比，从后往前进行对比，看看哪个数没有在它的相对位置上。以上面的序列为例，这里说的相对位置可以理解为我们从后往前搜索分别能找到8、7、6、5，但是理应在5前面的4却不见了，所以4是不在相对位置上的。因此4需要挪到最前面，在4前面的3、2、1也需要移到最前面。于是我们需要返回至少需要移动四次。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] sortArr = Arrays.copyOf(arr, n);</span><br><span class="line">		Arrays.sort(sortArr);</span><br><span class="line">		<span class="keyword">int</span> p = n - <span class="number">1</span>, q = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; q &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[p] == sortArr[q]) &#123;</span><br><span class="line">				--p;</span><br><span class="line">				--q;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; arr[p] != sortArr[q]) &#123;</span><br><span class="line">					--p;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> q + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			arr[i] = in.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">		System.out.println(s.fun(arr.length, arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于没有OJ环境，以上代码仅仅测试了我自己输入的部分测试用例。各位如果发现有什么问题可以在下方进行留言与我交流。</p>
]]></content>
      <categories>
        <category>笔试面试</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>从Java创建线程入门多线程</title>
    <url>/2020/08/03/%E4%BB%8EJava%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>本文是Java多线程系列的第一篇文章，关于线程的基础知识这里不多介绍，在我之前的文章中就已经介绍过了，不熟悉什么是线程的同学可以先去看一下。<a href="https://sky-ng.github.io/2020/06/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">操作系统-进程与线程</a></p>
<a id="more"></a>

<h2 id="从最老生常谈的Java创建线程方式谈起"><a href="#从最老生常谈的Java创建线程方式谈起" class="headerlink" title="从最老生常谈的Java创建线程方式谈起"></a>从最老生常谈的Java创建线程方式谈起</h2><p>稍微了解过一点Java多线程编程的朋友一定知道，Java创建线程的方式一般有三种：重写Thread类、实现Runnable和实现Callable接口，当然线程池也算是创建线程的一种方式，但那就扯远了，我们暂时从这三种方式聊起。</p>
<h3 id="重写Thread类"><a href="#重写Thread类" class="headerlink" title="重写Thread类"></a>重写Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"do something here..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的方式，重写Thread类的demo上面已给出。</p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"do something here..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样很简单，实现Runnable接口后将MyRunnable对象传给Thread类。</p>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FutureTask&lt;Boolean&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">		Thread t = <span class="keyword">new</span> Thread(result);</span><br><span class="line">		t.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(result.get());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"do something here..."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Callable接口这种方式与实现Runnable接口的不同之处在于多了一个返回值。</p>
<h2 id="start-和run-到底有什么区别"><a href="#start-和run-到底有什么区别" class="headerlink" title="start()和run()到底有什么区别"></a>start()和run()到底有什么区别</h2><p>首先需要明确的是，<code>start()</code>是一个native方法，该方法会启动一个线程，线程执行<code>run()</code>方法里的内容。与直接执行<code>run()</code>方法不同的是，<code>start()</code>会启动一个新的线程，这个线程与主线程并发执行。如果直接执行线程的<code>run()</code>方法就不会启动新的线程，相当于执行了一个普通方法。</p>
<h2 id="关于run-方法的细节"><a href="#关于run-方法的细节" class="headerlink" title="关于run()方法的细节"></a>关于run()方法的细节</h2><p><code>run()</code>方法作为创建线程的核心，我们这里就来扒一扒源码。</p>
<p>首先是Thread类的<code>run()</code>方法，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，Thread类中的<code>run()</code>方法就是调用Runnable对象的<code>run()</code>方法，我们再看一下Runnable接口的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable接口很简单，就是一个<code>run()</code>抽象方法。在Runnable接口上有个<code>@FunctionalInterface</code>注解，表明可以实现函数式编程。</p>
<h2 id="如果既继承了Thread类又实现了Runnable接口呢？"><a href="#如果既继承了Thread类又实现了Runnable接口呢？" class="headerlink" title="如果既继承了Thread类又实现了Runnable接口呢？"></a>如果既继承了Thread类又实现了Runnable接口呢？</h2><p>有没有想过当一个线程既继承了Thread类又实现了Runnable接口会执行哪个<code>run()</code>方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Runnable method"</span>)) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Thread method"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家觉得上面的代码会怎么执行？答案是执行匿名内部类中的方法，也就是打印<code>Thread method</code>。回顾一下之前分析的源码就不难知道，在Thread中执行的是target对象的<code>run()</code>方法，而这里我们在匿名内部类中重写了<code>run()</code>方法，与原来的父类<code>run()</code>方法已经没有关系了，自然也不会运行target对象的<code>run()</code>方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>你一定要了解的数据结构-并查集</title>
    <url>/2020/06/09/%E4%BD%A0%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>今天要介绍一种非常重要的数据结构-并查集，这种数据结构常常被用于检测有环图的问题。</p>
<a id="more"></a>

<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>给定一些节点，我们想要确定这些节点哪些属于同一个子集，该怎么做？现在假定这些节点之间通过边来连接，我们尝试用图片来表示一下。</p>
<p><img src="https://img-blog.csdnimg.cn/20200609133102467.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="节点通过边相连"></p>
<p>我们可以看到一共有6个节点，其中0、1、2、3这几个节点之间是连通的，4和5也是连通的。所以我们可以把上面6个节点分为两个集合，集合1包含0、1、2、3共4个节点，集合2包含4和5两个节点。</p>
<p>通过图片表示很直观，但是，我们如何用代码实现呢？</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>由上面的内容我们很容易知道，两个节点如果属于同一集合就能够找到一条路径连通这两个节点，但是怎么才能找到这条路径呢？我们需要对这些节点进行等级划分，每个节点只需要记住自己的上级节点即可，这样的话两个节点分别向上查找，一直找到顶层的节点，如果顶层节点相同，我们就判定这两个节点属于同一子集，否则不是同一子集。等等，这不就是树吗？说的没错，维基百科中这样定义并查集：在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。怎么样，是不是感觉并查集的设计思路很精妙。</p>
<p><img src="https://img-blog.csdnimg.cn/20200609142805355.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p>我们来思考一下并查集的代码怎么写，首先咱们需要设置一个<code>parent</code>数组用来存储上级节点，初始时数组中的所有值均为-1，表示没有上级节点，我们先来写一下这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span>[] parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VERTICES; ++i) &#123;</span><br><span class="line">		parent[i] = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个问题，怎么寻找根节点？咱们看一下刚刚那个<code>parent</code>数组是怎么用的。前面我们说过节点之间用边来相连，<code>parent</code>数组用来存储上级节点的下标。如下图所示，2和3的上级节点是1，1的上级节点是0，0是根节点。同理，5的上级节点是4，4也是根节点，所以一共有两个集合。</p>
<p><img src="https://img-blog.csdnimg.cn/20200609151257787.jpg#pic_center" alt="parent数组结构"></p>
<p>很容易发现，当<code>parent</code>存储的值为-1时表示这个节点就是根节点，我们用代码实现一下寻找根节点的算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x_root = x;</span><br><span class="line">	<span class="keyword">while</span> (parent[x_root] != -<span class="number">1</span>) &#123;</span><br><span class="line">		x_root = parent[x_root];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面说到寻找根节点的方法，下面咱们谈谈节点之间的边是怎么构建的。还是上面那幅图，我们现在要把上面的两个集合合并为一个集合该怎么做？很简单，把其中一个根节点的父节点设置为另一个根节点，比如像下面这样，把4的父节点设置为0。</p>
<p><img src="https://img-blog.csdnimg.cn/20200609154843602.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="合并两棵树以后的状态"></p>
<p>在下面的代码实现中，如果两个要构建边的节点在同一集合中就返回false，且不会建立这条边，如果不是在同一集合中就返回true，然后它们就成了同一集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回true则合并成功，返回false则合并失败</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">unionVertices</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x_root = findRoot(parent, x);</span><br><span class="line">	<span class="keyword">int</span> y_root = findRoot(parent, y);</span><br><span class="line">	<span class="keyword">if</span> (x_root == y_root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		parent[y_root] = x_root;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咱们看一下完整的代码实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> VERTICES = <span class="number">6</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span>[] parent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VERTICES; ++i) &#123;</span><br><span class="line">			parent[i] = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x_root = x;</span><br><span class="line">		<span class="keyword">while</span> (parent[x_root] != -<span class="number">1</span>) &#123;</span><br><span class="line">			x_root = parent[x_root];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x_root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回true则合并成功，返回false则合并失败</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">unionVertices</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x_root = findRoot(parent, x);</span><br><span class="line">		<span class="keyword">int</span> y_root = findRoot(parent, y);</span><br><span class="line">		<span class="keyword">if</span> (x_root == y_root) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			parent[y_root] = x_root;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DisjointSets d = <span class="keyword">new</span> DisjointSets();</span><br><span class="line">		<span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[d.VERTICES];</span><br><span class="line">		<span class="keyword">int</span>[] rank = <span class="keyword">new</span> <span class="keyword">int</span>[d.VERTICES];</span><br><span class="line">		<span class="keyword">int</span>[][] edges = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">		d.init(parent);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = edges[i][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> y = edges[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (!d.unionVertices(parent, x, y)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Cycle detected!"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"No cycles found!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化分析"><a href="#优化分析" class="headerlink" title="优化分析"></a>优化分析</h2><p>下面请大家考虑一个问题，假设我们有10000个点，边连接是<code>{0, 1}, {1, 2}, {2, 3}...</code>以此类推，那么用上面的算法我们将得到一条长长的链，也就是每次寻找根节点的时间复杂度为$O(n)$，这时候我们就需要对算法进行优化了。</p>
<p>我们来思考一下，当两棵树的高度不同时，应该怎么进行合并呢？还是最上面两棵树的合并，咱们看一下下面两种合并方式。</p>
<p><img src="https://img-blog.csdnimg.cn/20200609163743218.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="两种合并方式"></p>
<p>大家觉得第一种和第二种哪个更好？显然第一种优于第二种，因为第一种是将高度较小的树合并到高度较大的树上的，这样合并后的树的高度仍然是原来较大的树的高度，而相反树的高度则会变大。简单地说，如果使用第二种方式进行合并则会导致高度越来越大。</p>
<p>进行算法优化时，我们需要设置另一个数组<code>rank</code>，然后用这个数组来储存当前节点高度。实际需要修改的代码只有<code>init</code>和<code>unionVertices</code>两个方法，将原始的高度都设置为0，还有就是需要判断两棵树的高度并进行比较。贴一下优化之后的代码供大家与之前的代码进行比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisjointSets</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> VERTICES = <span class="number">6</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span>[] rank)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VERTICES; ++i) &#123;</span><br><span class="line">			parent[i] = -<span class="number">1</span>;</span><br><span class="line">			rank[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x_root = x;</span><br><span class="line">		<span class="keyword">while</span> (parent[x_root] != -<span class="number">1</span>) &#123;</span><br><span class="line">			x_root = parent[x_root];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x_root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回true则合并成功，返回false则合并失败</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">unionVertices</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span>[] rank, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x_root = findRoot(parent, x);</span><br><span class="line">		<span class="keyword">int</span> y_root = findRoot(parent, y);</span><br><span class="line">		<span class="keyword">if</span> (x_root == y_root) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (rank[x_root] &gt; rank[y_root]) &#123;</span><br><span class="line">				parent[y_root] = x_root;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[x_root] &lt; rank[y_root]) &#123;</span><br><span class="line">				parent[x_root] = y_root;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				parent[x_root] = y_root;</span><br><span class="line">				rank[y_root]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DisjointSets d = <span class="keyword">new</span> DisjointSets();</span><br><span class="line">		<span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[d.VERTICES];</span><br><span class="line">		<span class="keyword">int</span>[] rank = <span class="keyword">new</span> <span class="keyword">int</span>[d.VERTICES];</span><br><span class="line">		<span class="keyword">int</span>[][] edges = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">		d.init(parent, rank);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = edges[i][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> y = edges[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (!d.unionVertices(parent, rank, x, y)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Cycle detected!"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"No cycles found!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是本文的全部内容，并查集的算法需要仔细研究，在leetcode中会出现一些并查集相关的问题，能够掌握相关的知识并灵活运行就能迎刃而解。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程通信</title>
    <url>/2020/09/08/Java%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>线程通信是Java线程部分的重点，我们介绍一下常见的几种线程通信方式。</p>
<a id="more"></a>

<h2 id="线程锁与同步"><a href="#线程锁与同步" class="headerlink" title="线程锁与同步"></a>线程锁与同步</h2><p>锁机制是线程通信的一种重要方式。当多个线程竞争某一个对象时，一旦某个线程获得对象就会立刻将其上锁，其他线程只能等待锁被释放才可以继续竞争。当我们需要进行多个线程间的同步时，经常利用线程锁完成。</p>
<p>在下面的代码中，两个线程总会有一个执行先后顺序，但后执行的线程必须等待先执行的代码运行结束才可以执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectLock</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) System.out.println(<span class="string">"MyRunnableA: "</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) System.out.println(<span class="string">"MyRunnableB: "</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnableA(), <span class="string">"线程1"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnableB(), <span class="string">"线程2"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果显示一个线程运行结束了以后才可以运行下一个线程。</p>
<p><img src="https://img-blog.csdnimg.cn/20200910193445452.png#pic_center" alt=""></p>
<h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>等待/通知机制同样是线程通信方式中比较重要的方法，这里的等待使用的是Object类中的<code>wait()</code>方法，通知使用的是Object类中的<code>notify()</code>或<code>notifyAll()</code>方法，以上三个方法都必须在<code>synchronized</code>中使用。<code>notify()</code>方法一次只能随机唤醒一个等待线程，而<code>notifyAll()</code>会唤醒所有的等待线程。当线程使用<code>wait()</code>方法时，会自动释放占有的锁资源。我们用代码来查看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">					System.out.println(<span class="string">"MyRunnableA: "</span> + i);</span><br><span class="line">					obj.notify();</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						obj.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				obj.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">					System.out.println(<span class="string">"MyRunnableB: "</span> + i);</span><br><span class="line">					obj.notify();</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						obj.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				obj.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnableA(), <span class="string">"线程1"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnableB(), <span class="string">"线程2"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码交替等待和唤醒对方从而实现交替打印的效果，结果如下。</p>
<p><img src="https://img-blog.csdnimg.cn/20200910210134998.png#pic_center" alt=""></p>
<h2 id="volatile共享内存"><a href="#volatile共享内存" class="headerlink" title="volatile共享内存"></a>volatile共享内存</h2><p>volatile关键字保证了线程间的内存可见性，本文暂不展开讲，后面会有专门的文章讲volatile和JMM（Java内存模型）相关的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"start time: "</span> + System.currentTimeMillis());</span><br><span class="line">			<span class="keyword">while</span> (flag) ;</span><br><span class="line">			System.out.println(<span class="string">"flag已被置为false"</span>);</span><br><span class="line">			System.out.println(<span class="string">"end time: "</span> + System.currentTimeMillis());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"flag即将被置为false"</span>);</span><br><span class="line">			flag = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnableA(), <span class="string">"线程1"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnableB(), <span class="string">"线程2"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的代码线程1初始时会阻塞在while循环里，但是线程2休眠1秒后将主内存中的<code>flag</code>改成了false，线程1第一时间获取了主内存的变量值变化并退出循环。具体结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2020091220431077.png#pic_center" alt=""></p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>Java提供了四个类来实现管道，分别是<code>PipedReader</code>、<code>PipedWriter</code>、<code>PipedInputStream</code>和<code>PipedOutputStream</code>。前两个是面向字符的，后两个是面向字节的。下面的代码实现了一个简单的管道通信，模拟了C/S结构的通信。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> PipedReader reader = <span class="keyword">new</span> PipedReader();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> PipedWriter writer = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">int</span> receivedData = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span> ((receivedData = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">					System.out.print((<span class="keyword">char</span>)receivedData);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					reader.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				writer.write(<span class="string">"test"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					writer.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">		writer.connect(reader);</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Server()).start();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Client()).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>学过操作系统的同学们一定对信号量的概念不陌生，在Java中有一个定义信号量的工具类Semaphore。我们以一个经典的生产者-消费者模型来测试一下这种通信方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Semaphore mutex;</span><br><span class="line">		Semaphore empty;</span><br><span class="line">		Semaphore full;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Semaphore mutex, Semaphore empty, Semaphore full)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">			<span class="keyword">this</span>.empty = empty;</span><br><span class="line">			<span class="keyword">this</span>.full = full;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">"生产一些东西"</span>);</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">					empty.acquire();</span><br><span class="line">					mutex.acquire();</span><br><span class="line">					System.out.println(<span class="string">"将数据放入缓冲中"</span>);</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">					mutex.release();</span><br><span class="line">					full.release();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		Semaphore mutex;</span><br><span class="line">		Semaphore empty;</span><br><span class="line">		Semaphore full;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Semaphore mutex, Semaphore empty, Semaphore full)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">			<span class="keyword">this</span>.empty = empty;</span><br><span class="line">			<span class="keyword">this</span>.full = full;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					full.acquire();</span><br><span class="line">					mutex.acquire();</span><br><span class="line">					System.out.println(<span class="string">"将数据从缓冲中取出"</span>);</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">					mutex.release();</span><br><span class="line">					empty.release();</span><br><span class="line">					System.out.println(<span class="string">"消费一些东西"</span>);</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">		Semaphore empty = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">		Semaphore full = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(mutex, empty, full)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(mutex, empty, full)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码模拟了经典的生产者-消费者模型，生产者一直在生产产品，消费者一直在消费产品，我们可以得到下面的运行结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200912224504698.png#pic_center" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法与归并排序</title>
    <url>/2020/06/13/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>距离上次写快排算法的文章已经过去一个半月了，和本文要提到的归并排序算法类似，快排也是分治思想的一种典型应用，如果有不熟悉快速排序的同学可以翻阅我之前写过的快速排序算法的文章。</p>
<a id="more"></a>

<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>首先为大家介绍一下什么是分治，分治是将一个大问题分割成若干个和原来问题形式相同但规模更小的子问题，然后处理这些小问题，最终实现整个大问题的过程。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613153944675.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p>额…上面说的概念确实很难理解，我们换一个生活中的场景来介绍一下什么是分治吧。</p>
<p>小明手里有8枚硬币，其中有1枚是假币，已知假币比真币轻，现在我们有一架天平，那么我们该怎么找出假币呢？</p>
<p>首先我们将硬币分成两组，每组4枚硬币，分别放到天平上称，硬币一定在轻的那一组里，再次将轻的那一边的硬币分成两组，每组2枚硬币，然后再取轻的那一边在进行二分，直到最后将2枚硬币放在天平上，轻的那一枚就是假币。这里用的就是简单的分治思想，每次把问题规模缩小一半，这里不仅是分治思想，其实也是用到了二分法的思想。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613155043295.jpg#pic_center" alt=""></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是分治算法的一种典型应用，基本思路如下：</p>
<ul>
<li><p>将数组的前一半进行排序</p>
</li>
<li><p>将数组的后一半进行排序</p>
</li>
<li><p>将两半数据归并成为一个有序的数组，并拷贝回原数组</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200613164330511.jpg#pic_center" alt=""></p>
<p>不多逼逼，直接给你们看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span>[] tmp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt; e) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = s + ((e - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		mergeSort(arr, s, m, tmp);</span><br><span class="line">		mergeSort(arr, m + <span class="number">1</span>, e, tmp);</span><br><span class="line">		merge(arr, s, m, e, tmp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> e, <span class="keyword">int</span>[] tmp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;	<span class="comment">//指向tmp数组当前位置的指针</span></span><br><span class="line">	<span class="keyword">int</span> p1 = s, p2 = m + <span class="number">1</span>; <span class="comment">//p1和p2分别指向分成两组后两边数组的首位置</span></span><br><span class="line">	<span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[p1] &gt; arr[p2]) &#123;</span><br><span class="line">			tmp[p++] = arr[p2++];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tmp[p++] = arr[p1++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">		tmp[p++] = arr[p1++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p2 &lt;= e) &#123;</span><br><span class="line">		tmp[p++] = arr[p2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e - s + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		arr[s + i] = tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咱们来梳理一下上面的代码，首先是<code>mergeSort</code>方法，当起始位置小于终止位置的时候才会执行代码，否则直接结束这个方法。再看看这个判断语句里的内容，首先是求出数组的中点，对数组一分为二进行分治，然后这两个数组又递归调用这个方法，最后对两个已经排好序的数组执行<code>merge</code>方法，进行归并操作。我们可以知道的是，当分到一定程度（s和e指向相同的元素）时，会结束递归，进行归并。我们用一组数据来模拟这个过程。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613171107537.jpg#pic_center" alt="待排序数组"></p>
<p>以上是一个待排序的数组，数组长度为10，因此传入的s和e分别为0和9，求出的m值为4，于是将数组分为下标0<del>4和下标5</del>9的两个数组再分别进行归并排序。</p>
<p>为了简化内容，我们尝试对前一个数组进行递归。此时传入的s和e分别是0和4，则m是2，再对前一个数组进行递归，s和e是0和2，m是1，继续递归，s和e是0和1，m是0，这时候两个数组都只有一个数了，这时候就需要对这两个数进行<code>merge</code>操作。所谓的<code>merge</code>操作，就是将两个数组中的元素按从小到大的顺序复制到tmp数组中，然后复制回arr数组中。咱们下面用图片来展示一下上面的代码到底对这个数组干了些什么。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613184701300.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="归并排序过程"></p>
<p>实际上，上述过程只是逻辑上的切分和归并，事实上由于递归需要不断压栈以及以上代码需要顺序执行，切分和归并的次数还要更多一些。</p>
<p>最后需要提到的是，归并排序是一种稳定的排序算法，时间复杂度为$O(nlogn)$。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>后浪-下一代垃圾收集器</title>
    <url>/2020/06/14/%E5%90%8E%E6%B5%AA-%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<p>随着Java虚拟机技术的不断发展，垃圾收集器也进行了大量迭代。前面介绍了7种经典的垃圾收集器，各有优缺点。Serial GC虽然是最古老的垃圾收集器，但由于设计简单，未必就是过时的收集器。CMS收集器由于自身有些算法缺陷，在JDK9中被标记为废弃，在最新版的JDK14中，CMS已经被彻底移除，进入了历史垃圾堆。我们可以发现G1收集器在JDK的各个版本中仍然在不断改进，并且成为了JDK9到JDK13的默认垃圾收集器。今天，我们要介绍的三种垃圾收集器算是垃圾收集器的前沿成果。</p>
<a id="more"></a>

<h2 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h2><p>我们看一下JEP 318中对于Epsilon收集器的介绍：</p>
<blockquote>
<p>Develop a GC that handles memory allocation but does not implement any actual memory reclamation mechanism. Once the available Java heap is exhausted, the JVM will shut down.</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020061419132816.jpg#pic_center" alt=""></p>
<p>好吧，翻译成中文就是说这款垃圾收集器可以分配内存但是不实现垃圾回收机制。一旦可用的Java堆内存耗尽，JVM就会关闭。</p>
<p><img src="https://img-blog.csdnimg.cn/20200614191722120.jpg#pic_center" alt=""></p>
<p>纳尼？垃圾收集器没有垃圾收集功能叫什么垃圾收集器？实际上Epsilon收集器提供有限分配限制和尽可能低的延迟开销的消极GC实现，尽管会以占用一定内存和牺牲一定内存吞吐量为代价。如果只是需要运行几分钟甚至几秒的小应用，那么JVM负责给对象分配内存，程序在堆内存消耗殆尽之前退出，这种场景下Epsilon收集器是很不错的选择。</p>
<h2 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h2><p>Shenandoah收集器算是最特别的一款垃圾收集器，它是由Red Hat研发的低延迟垃圾收集器，之所以说它特别，是因为研发团队将它引入OpenJDK 12的时候，Oracle官方却不愿意将它加入HotSpot中，导致了开源版比商用版功能更多的尴尬。</p>
<p>Red Hat团队设计这款收集器的最初目的是为了将垃圾收集的延迟降低到10毫秒以内，不管是200MB还是200GB的垃圾都要达到这样的目标，但Shenandoah开发团队的实际测试似乎并没有达到最初的目标，尽管停顿时间确实是大大降低了。停顿时间的降低必然会造成别的参数性能下降，在吞吐量方面，Shenandoah收集器比起G1、CMS等收集器还是有一定差距的。</p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>Shenandoah收集器非常像是G1的改进版本，它的工作过程大致可以分为以下阶段：</p>
<ul>
<li><p>初始标记。标记和GC Roots直接关联的对象，这个过程需要STW（Stop the world），该过程停顿时间只与GC Roots的数量相关。</p>
</li>
<li><p>并发标记。与用户线程并发执行，遍历对象图，标记所有可达对象。</p>
</li>
<li><p>最终标记。同样需要STW，并扫描剩余STAB，统计最有回收价值的Region，并将这些Region组成回收集。</p>
</li>
<li><p>并发清理。清理没有存活对象的Region。</p>
</li>
<li><p>并发回收。将回收集中的存活对象复制到空白Region中，并且这个阶段是与用户线程并发执行的，用户线程有可能继续访问原来的内存地址，所以利用读屏障和Brooks Pointers转发指针。</p>
</li>
<li><p>初始引用更新。需要STW，建立线程集合点，确保并发回收阶段的存活对象已经移到其他Region中。</p>
</li>
<li><p>并发引用更新。按物理内存顺序，线性搜索引用类型，将旧值改成新值。</p>
</li>
<li><p>最终引用更新。短暂的STW，修正GC Roots的引用。</p>
</li>
<li><p>并发清理。将回收集中的内存全部回收。</p>
</li>
</ul>
<h3 id="Brooks-Pointers"><a href="#Brooks-Pointers" class="headerlink" title="Brooks Pointers"></a>Brooks Pointers</h3><p>现在解释一下并发回收里的Brooks Pointers，我们知道，在并发回收的过程中可能有用户程序继续访问旧地址，但是访问旧地址势必会出错，因此提出了转发指针的概念（其实Brooks是个人名）。</p>
<p><img src="https://img-blog.csdnimg.cn/2020061522011670.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="Brooks Pointers示意图1"></p>
<p>转发指针是设置在原有对象前的一个引用字段，正常情况下指向对象自身。并发回收阶段把旧对象的转发指针指向新对象的地址。</p>
<p><img src="https://img-blog.csdnimg.cn/202006152211433.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="Brooks Pointers示意图2"></p>
<h3 id="Shenandoah相比G1的改进"><a href="#Shenandoah相比G1的改进" class="headerlink" title="Shenandoah相比G1的改进"></a>Shenandoah相比G1的改进</h3><p>Shenandoah收集器其实可以看做是G1的继承版本，这两款收集器的工作步骤很多都是一样的，甚至还共享了代码。但是Shenandoah收集器其实还是有很多改进的地方的，以下介绍一下改进之处：</p>
<ul>
<li><p>Shenandoah收集器支持并发整理而G1回收内存不能与用户线程并发执行。</p>
</li>
<li><p>Shenandoah收集器默认不使用分代收集。</p>
</li>
<li><p>Shenandoah收集器不再使用记忆集记录跨Region的引用而是改用连接矩阵。</p>
</li>
</ul>
<p>简单介绍一下连接矩阵，连接矩阵可理解为一个二维表格，如果Region M指向Region N则在表格的M行N列做一个标记。</p>
<h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>和Shenandoah一样，ZGC也希望能将延迟时间压缩到10毫秒以内。它是JDK11引入的实验性质的低延迟收集器，这可是根红苗正的Oracle亲儿子。</p>
<p><img src="https://img-blog.csdnimg.cn/20200615223858595.png?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>ZGC是暂时不使用分代机制的，它的内存布局主要有小型Region、中型Region和大型Region。</p>
<p><img src="https://img-blog.csdnimg.cn/20200616160122298.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70" alt=""></p>
<ul>
<li><p>小型Region：容量为2MB，存放小于256KB的对象。</p>
</li>
<li><p>中型Region：容量为32MB，存放小于4MB但大于256KB的对象。</p>
</li>
<li><p>大型Region：容量不固定，但必须是2MB的整数倍，用于存放4MB及以上大小的对象，也就是说最小容量只有4MB，比中型Region小，但是大型Region只能存放一个对象。</p>
</li>
</ul>
<h3 id="染色指针"><a href="#染色指针" class="headerlink" title="染色指针"></a>染色指针</h3><p>染色指针是ZGC与其他垃圾收集器的区别之一，它将少量对象信息直接存储在指针上。以64位Linux为例，它的高18位不能用来寻址，剩下的46位中4位是标志位，用来表示引用对象的状态，剩下42位用来寻址，最大支持4TB内存。</p>
<p><img src="https://img-blog.csdnimg.cn/20200616171719124.png?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="染色指针"></p>
<p>上面的四位标志位中Marked0和Marked1表示引用对象的三色标记状态，Remapped表示是否被移动过，Finalizable表示是否只能通过finalize()方法访问到。染色指针指向的存活对象被移走后，对象所在的Region立马就可以被释放。</p>
<h3 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h3><ul>
<li><p>并发标记。并发标记前面已经提过很多次了，遍历对象图，需要STW，但是ZGC的标记是标记在染色指针上的。也就是染色指针的Marked0和Marked1两个标志位，用来标识对象状态。</p>
</li>
<li><p>并发预备重分配。ZGC将所有要收集的Region组成重分配集，ZGC会扫描所有的Region来换维护记忆集的成本。</p>
</li>
<li><p>并发重分配。该过程将重分配集中的存活对象复制到其他Region中，并为重分配集维护一个转发表记录旧对象到新对象的迁移。从染色指针的状态位可以知道对象是否还在重分配集中，如果在的话，会被内存屏障拦截并转发到新对象，然后更新引用使其指向新对象。</p>
</li>
<li><p>并发重映射。该过程所做的工作就是修正所有的Region中指向重分配集的引用，但这并不是紧迫的任务，因为大不了就是第一次使用多一次转发。一旦所有引用都被修正，原来的转发表就可以释放了。</p>
</li>
</ul>
<h3 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h3><p>ZGC支持NUMA的内存架构，NUMA的中文是非统一内存访问，介绍它之前首先介绍一下UMA（统一内存访问）。</p>
<p><img src="https://img-blog.csdnimg.cn/2020061615085157.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="UMA"></p>
<p>在以前的计算机发展中，这样的总线模型保证了所有CPU对内存的访问地址还是一致的。但随着CPU核心数的增加，这样的架构显然无法适应现状。于是发展出了NUMA内存架构。在NUMA架构中，CPU和内存被划分成多个不同的节点，不同节点之间可以通过QPI（Quick Path Interconnect）进行访问。ZGC会优先在当前线程所属的CPU的本地内存中进行访问，这样可以大大加快CPU访问内存的速度。</p>
<p><img src="https://img-blog.csdnimg.cn/20200616151610492.jpg?x-oss-type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="NUMA"></p>
<h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>去年我的一个学长分享了某互联网公司内部员工培训的JVM课件，已经将ZGC加入到培训内容中。可以预见的是，ZGC由于是Oracle官方推出的根红苗正的垃圾收集器，有很大概率会出现在今后甚至是今年即将到来的秋招面试大礼包中。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序Java代码简洁实现</title>
    <url>/2020/04/29/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FJava%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>学习过数据结构的同学们都知道，快速排序算法是一种时间复杂度为O(nlogn)的排序算法，在各种排序算法中算是较为高效的方法，企业面试中也经常有手撕快排的环节。本文将阐述算法的基本思想，并用Java代码的形式实现快速排序代码。</p>
<a id="more"></a>

<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>快速排序主要采用分治的基本思想，每次将一个位置上的数据归位，此时该数左边的所有数据都比该数小，右边所有的数据都比该数大，然后递归将已归位的数据左右两边再次进行快排，从而实现所有数据的归位。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>我们有一组待排序数据：</p>
<blockquote>
<p>5  2  6  9  1  3  4  8  7  10</p>
</blockquote>
<p>我们首先拿到数组中的首个数字k=5，并且设置两个指针i和j。将i设置指向数组的起始数字5，j设置指向数组的末尾数字10。首先将j指向的数字与k比较，如果比k小，则将i和j指向的数字交换，如果不小于k则j指针不断向前移动。我们可以看到本例中j的移动过程是10-&gt;7-&gt;8-&gt;4，此时4比5小，则交换4和5，变成了如下序列：</p>
<blockquote>
<p>4  2  6  9  1  3  5  8  7  10</p>
</blockquote>
<p>每次交换后，另一个指针开始移动，i指针不断向后移动，寻找比5大的数字。i的移动过程是4-&gt;2-&gt;6，此时6比5大，则交换5和6，变成了如下序列：</p>
<blockquote>
<p>4  2  5  9  1  3  6  8  7  10</p>
</blockquote>
<p>再次轮到j指针向前移动，移动过程是6-&gt;3，此时3比5小，则交换3和5，变成了如下序列：</p>
<blockquote>
<p>4  2  3  9  1  5  6  8  7  10</p>
</blockquote>
<p>再次轮到i指针向后移动，移动过程是3-&gt;9，此时9比5大，则交换9和5，变成了如下序列：</p>
<blockquote>
<p>4  2  3  5  1  9  6  8  7  10</p>
</blockquote>
<p>再次轮到j指针向前移动，移动过程是9-&gt;1，此时1比5小，则交换1和5，变成了如下序列：</p>
<blockquote>
<p>4  2  3  1  5  9  6  8  7  10</p>
</blockquote>
<p>此时i指针和j指针相遇，数字5归位。再利用上述思想递归将5左右两边的序列进行排序，最终所有数字归位即可结束。</p>
<h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> k = arr[start];</span><br><span class="line">		<span class="keyword">int</span> i = start, j = end;</span><br><span class="line">		<span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">			<span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= k)</span><br><span class="line">				--j;</span><br><span class="line">			swap(arr, i, j);</span><br><span class="line">			<span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= k)</span><br><span class="line">				++i;</span><br><span class="line">			swap(arr, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">		quickSort(arr, start, i - <span class="number">1</span>);</span><br><span class="line">		quickSort(arr, i + <span class="number">1</span>, end);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">		<span class="keyword">new</span> QuickSort().quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><p><a href="https://www.icourse163.org/learn/PKU-1001894005#/learn/content?type=detail&id=1214952553&sm=1" target="_blank" rel="noopener">程序设计与算法（二）算法基础-快速排序</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>拼多多面试官：说说数据库事务隔离级别</title>
    <url>/2020/10/11/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<p>什么是数据库事务？数据库事务是一系列数据库操作的集合，数据库事务是数据库管理系统与文件系统的重要区别之一。</p>
<a id="more"></a>

<h1 id="从事务的四个特性谈起"><a href="#从事务的四个特性谈起" class="headerlink" title="从事务的四个特性谈起"></a>从事务的四个特性谈起</h1><p><img src="https://img-blog.csdnimg.cn/20201013212154930.png#pic_center" alt=""></p>
<p>记得之前一个教数据库的老师说过，如果考研复试遇到了她，一定会问什么是ACID。一般学过数据库的同学基本都能说上一些。A指的是Atomicity，也就是<strong>原子性</strong>，原子性是指一个事务的所有操作要么全部做完，要么全部不做，不存在停在中间环节的情况。C指的是Consistency，也就是<strong>一致性</strong>，事务在执行前后，数据保持一致。例如小张给小王转了100块钱，那么小张的账户里少了100元，同时小王的账户里多了100元，但是他们的总金额不变。I是Isolation，是指<strong>隔离性</strong>，数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。D指<strong>持久性</strong>（Durability），是指事务一旦结束，对数据的修改就是永久性的。</p>
<h1 id="事务并发带来的问题"><a href="#事务并发带来的问题" class="headerlink" title="事务并发带来的问题"></a>事务并发带来的问题</h1><p>事务并发往往会带来一些不可预知的问题，一般可以包括<strong>脏读</strong>、<strong>幻读</strong>、<strong>不可重复读</strong>和<strong>丢失更新</strong>。</p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p><img src="https://img-blog.csdnimg.cn/20201013214221215.png#pic_center" alt=""></p>
<p>脏读是指事务A未提交的数据被事务B读取，事务A回滚，事务B读到的数据是脏数据。</p>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p><img src="https://img-blog.csdnimg.cn/20201013220300869.png#pic_center" alt=""></p>
<p>幻读是指事务A查询一次数据后，事务B增加或减少了几条数据，事务A再次查询发现和之前查到的数据条数不一致，就好像出现了幻觉一样。</p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p><img src="https://img-blog.csdnimg.cn/20201013221128744.png#pic_center" alt=""></p>
<p>不可重复读是事务A两次查询期间事务B修改了数据，导致事务A两次读取的数据不一致。</p>
<h2 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h2><p><img src="https://img-blog.csdnimg.cn/20201013222603105.png#pic_center" alt=""></p>
<p>丢失更新指的是事务A和事务B同时写一个数据，那么先写的更新就会丢失，还有一种情况是两个事务同时更新一条数据，某一事务回滚导致另一事务的更新也丢失。</p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>事务有四种隔离级别，由低到高分别是<strong>读未提交</strong>、<strong>读已提交</strong>、<strong>可重复读</strong>和<strong>可串行化</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201015234759109.png#pic_center" alt=""></p>
<ul>
<li><p>读未提交(READ UNCOMMITTED)：读未提交是最低的隔离级别，不同事务之间可以读取未提交的数据，因此可能产生脏读、不可重复读和幻读。</p>
</li>
<li><p>读已提交(READ COMMITTED)：读已提交的级别略高于读未提交，事务之间只能读取已经提交的数据，可能产生不可重复读和幻读的问题。</p>
</li>
<li><p>可重复读(REPEATABLE READ)：可重复读对同一字段多次读取的结果一致，可以防止脏读和不可重复读，但还是会产生幻读的问题。</p>
</li>
<li><p>可串行化(SERIALIZABLE)：可串行化是最高级别的事务隔离级别，是完全串行化执行事务，可以有效防止幻读、不可重复读和脏读。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-处理机调度</title>
    <url>/2020/06/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p>本文介绍处理机调度相关的内容，主要涉及三级调度与调度算法等知识。</p>
<a id="more"></a>

<h2 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h2><p>作业从提交到完成一般需要经历三级调度：<strong>作业调度</strong>（高级调度）、<strong>内存调度</strong>（中级调度）和<strong>进程调度</strong>（低级调度），调度的频率依次递增。</p>
<ul>
<li><p><strong>作业调度</strong>：作业调度一般是将一个作业从外存调入内存，为其分配内存、外设等资源，使其能够竞争处理机资源。对每个作业来说，每个作业一般只调入一次、调出一次。</p>
</li>
<li><p><strong>内存调度</strong>：内存调度是为了<strong>提高内存利用率</strong>和<strong>系统吞吐量</strong>，一般会将暂时无法运行的进程挂起，当具备运行条件且内存有空闲时，会将这些进程调回，挂在就绪队列上等待调度。</p>
</li>
<li><p><strong>进程调度</strong>：最频繁的调度方式，一般从就绪队列中调出一个进程，为它分配处理机资源。</p>
</li>
</ul>
<h2 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h2><ul>
<li><p><strong>非剥夺调度方式</strong>：当一个进程处于运行状态时，即使有更紧急或优先级更高的进程进入就绪队列，也不会抢占正在运行进程的处理机资源，只有当前运行进程结束运行或进入阻塞状态时才会从就绪队列将更紧迫的进程调出并分配处理机资源。</p>
</li>
<li><p><strong>剥夺调度方式</strong>：当有一个更紧急或优先级更高的进程需要使用处理机，当前进程会被暂停，执行更紧迫进程的调度方式。</p>
</li>
</ul>
<h2 id="调度基本准则"><a href="#调度基本准则" class="headerlink" title="调度基本准则"></a>调度基本准则</h2><ul>
<li><p>CPU利用率：当CPU一直处于忙碌状态时，CPU利用率最高。</p>
</li>
<li><p>系统吞吐量：表示单位时间内完成的作业数量，当作业都是短作业时，系统吞吐量会比较大。</p>
</li>
<li><p>周转时间：是作业从提交到完成的时间，包括作业等待、在就绪队列排队、运行、IO操作的时间总和。</p>
</li>
<li><p>平均周转时间：是多个作业的周转时间的平均值。</p>
</li>
<li><p>带权周转时间：$带权周转时间=\frac{作业周转时间作业}{实际运行时间}$</p>
</li>
<li><p>平均带权周转时间：是多个带权周转时间的平均值。</p>
</li>
<li><p>等待时间：进程等待处理机的时间之和。</p>
</li>
<li><p>响应时间：从用户提交到首次响应所花费的时间。</p>
</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>调度算法是本文的重点，也是很常见的考点，以下介绍常见的调度算法。</p>
<h3 id="先来先服务（FCFS）调度算法"><a href="#先来先服务（FCFS）调度算法" class="headerlink" title="先来先服务（FCFS）调度算法"></a>先来先服务（FCFS）调度算法</h3><p>从名字就可以知道这是一种“先来后到”的调度算法，这种调度算法支持作业调度和进程调度。FCFS调度算法每次挑选队列中最先到达的进程或作业，依次进行调度。<br>这是一种<strong>非剥夺调度算法</strong>，直观来看，非常公平，但是还是有缺点的。</p>
<p>特点：算法简单，但效率低，对长作业有利，短作业可能要等待很长时间。有利于CPU密集型作业，不利于IO密集型作业。</p>
<h3 id="短作业-进程优先（SJF-SPF）调度算法"><a href="#短作业-进程优先（SJF-SPF）调度算法" class="headerlink" title="短作业/进程优先（SJF/SPF）调度算法"></a>短作业/进程优先（SJF/SPF）调度算法</h3><p>短作业/进程优先算法是一种优先调度短作业（进程）的调度算法，同样也是一种<strong>非剥夺调度算法</strong>。</p>
<p>特点：对短作业有利，对长作业不利，如果一直有短作业进来，可能长作业会一直得不到执行。不考虑作业紧迫程度，有些紧迫的作业可能不能及时处理。有利于IO密集型作业，不利于CPU密集型作业。</p>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>优先级调度算法既可以用于作业调度也可以用于进程调度。当用于作业调度时，会从后备作业队列中选出一个或多个优先级最高的作业，将它们调入内存中，并分配相应资源；当用于进程调度时，会从就绪队列中选出优先级最高的进程，将处理机分配给这个进程，使它能够运行。</p>
<p>根据高优先级进程能否抢占处理机还可以将这种算法分为非剥夺式优先级调度算法和剥夺式优先级调度算法。</p>
<p>在进程创建后进程优先级能否改变又可以将进程优先级分为静态优先级和动态优先级。</p>
<ul>
<li><p>静态优先级。静态优先级是进程在创建时就已经确定好的，在进程运行期间不能改变。</p>
</li>
<li><p>动态优先级。动态优先级是指进程运行期间优先级根据进程实际运行情况动态变化的。</p>
</li>
</ul>
<h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p>高响应比优先调度算法适用于作业调度，是短作业优先调度算法和先来先服务算法的折中。我们先来看一下什么是响应比吧。</p>
<p>$$响应比=\frac{等待时间+要求服务时间}{要求服务时间}$$</p>
<p>高响应比优先调度算法具有以下特点：</p>
<ul>
<li><p>短作业的要求服务时间很短，因此在相同等待时间的情况下，短作业的响应比也更高，会被优先执行。</p>
</li>
<li><p>当要求服务时间相同时，等待时间长的作业会被优先服务。</p>
</li>
<li><p>长作业的要求服务时间比较长，但是随着等待时间的增加，长作业的响应比也会增加，然后可以分配处理机。</p>
</li>
</ul>
<h3 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h3><p>时间片轮转调度算法一般在分时系统上使用，每个进程被分配固定大小的时间片，当时间片用完以后，无论进程是否执行结束，处理机都将被剥夺给下一个进程。</p>
<p>特点：时间片轮转调度算法的时间片大小选择很讲究，如果时间片过大，该调度算法会退化成为先来先服务调度算法，而时间片设置过小，处理机会频繁切换，进程真正使用处理机的时间减少，系统吞吐量下降。</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>多级反馈队列调度算法是这些调度算法中最复杂的，也是整合了前面一些调度算法而形成的算法，我们来看一下它的工作过程。</p>
<p><img src="https://img-blog.csdnimg.cn/20200618151104803.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="多级反馈队列调度算法"></p>
<p>多级反馈队列调度算法工作过程有以下这些特点：</p>
<ul>
<li><p>每一级队列从上至下的优先级逐渐递减，优先级越高的队列时间片越小。也就是说，最顶层的队列的时间片最小。</p>
</li>
<li><p>最新的进程进入内存会被放入最上层的队列末尾，当执行到这个进程时，如果能在分配的时间片内完成则会出队列，如果不能在时间片内完成就进入下一级队列末尾，等待处理机资源。</p>
</li>
<li><p>如果高优先级队列有进程存在，则处理机会优先处理上级队列中的进程。如果处理机正在执行某一队列中的进程，此时更高优先级队列中有进程进入，那么当前正在执行的进程会回到当前队列的队尾，处理机执行新进入队列的进程。</p>
</li>
</ul>
<p>最后要提一点，多级反馈队列调度算法兼顾短作业优先的同时，不会让长作业长期处于等待状态最终出现饥饿。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-概述</title>
    <url>/2020/06/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>本文是操作系统系列文章的第一篇，后续将陆续更新操作系统相关的文章。</p>
<a id="more"></a>

<h2 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h2><p>计算机系统自底向上大致可分为四个部分：硬件、操作系统、应用程序和用户，我们这里比较关心位于硬件之上的操作系统。操作系统是控制和管理硬件和软件资源，组织调度计算机工作和资源分配，并为用户提供接口与环境的程序集合。</p>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><ul>
<li><p>并发。并发是指多个事件在同一时间段内发生，当我们一边在QQ上聊天，一边听着音乐，此时操作系统同时处理着多个程序，我们可以说QQ和播放器是并发执行的。需要注意的是，与并发容易混淆的概念——并行，并行是指多个事件在同一时刻同时执行。</p>
</li>
<li><p>共享。系统中某些资源是可以允许多个进程使用的，共享分为互斥共享与同时访问方式。互斥共享典型代表如打印机，每次只允许一个进程使用。同时访问的“同时”体现在宏观层面上，而微观层面上是“分时共享”的。</p>
</li>
<li><p>虚拟。虚拟是指将一个物理上的实体对应变为多个逻辑上的实体，常见的虚拟技术有虚拟处理器、虚拟内存和虚拟外设等。</p>
</li>
<li><p>异步。多道程序系统允许多程序并发执行，多个程序并非一次执行到底，而是走走停停，以为止速度向前推进。</p>
</li>
</ul>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><ul>
<li><p>处理机管理</p>
</li>
<li><p>存储器管理</p>
</li>
<li><p>文件管理</p>
</li>
<li><p>设备管理</p>
</li>
<li><p>为用户提供接口</p>
</li>
</ul>
<h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><p>这种方式是最早的操作方式，由人工直接使用计算机硬件系统，这种方式主要有两个缺点：</p>
<ul>
<li><p>用户独占全机。此时的计算机由操作人员一个人独占。</p>
</li>
<li><p>CPU等待用户操作。由于手工操作较慢，CPU资源长时间是空闲的。</p>
</li>
</ul>
<p>也正是因为上述缺点的存在，人机矛盾原来越严重，此时唯一的解决方法是用机器代替手工进行作业控制。</p>
<h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h3><p>为了解决人机矛盾扩大的问题，批处理系统很快被提出。批处理阶段又分为单道批处理系统和多道批处理系统。单道批处理系统允许内存中保持一道作业，当遇到IO操作时，CPU会等待IO操作完成。为了提高系统吞吐量，又提出了多道批处理系统。多道批处理系统允许多个程序进入内存并且能在CPU中交替运行，当一个程序执行IO操作时，CPU立马运行另一个程序。</p>
<h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>分时是将处理器运行时间划分成为时间片，每个作业分别分配到这些时间片。当一个时间片用完时，某个作业会暂停，CPU会执行下一个程序。由于作业轮转很快，所以用户会感觉独占了计算机。</p>
<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>实时操作系统是需要在规定时间内完成特定任务的系统，又可以分为硬实时系统和软实时系统。硬实时系统要求某个动作在某一时刻（或某一时间段）必须完成，例如无人机的飞控系统。软实时系统能够接受偶尔的超时但又不会造成严重后果，例如12306订票系统。</p>
<h3 id="网络操作系统和分布式计算机系统"><a href="#网络操作系统和分布式计算机系统" class="headerlink" title="网络操作系统和分布式计算机系统"></a>网络操作系统和分布式计算机系统</h3><p>网络操作系统将网络中的计算机连接起来，实现计算机之间的数据通信。分布式计算机有多台计算机组成，每台计算机拥有相同的地位，没有主从关系。分布式操作系统与网络操作系统之间的不同之处在于分布式操作系统是协同完成同一任务的计算机集群。</p>
<h3 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h3><p>常见的个人操作系统有Windows和Linux等。</p>
<h2 id="操作系统运行环境"><a href="#操作系统运行环境" class="headerlink" title="操作系统运行环境"></a>操作系统运行环境</h2><h3 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h3><p>内核态又称核心态、管态，通常是系统内核执行特权指令时的状态，特权指令是指不能由应用程序直接执行的指令，如IO指令、置中断指令等。用户态又称目态，是上层应用程序运行时CPU的状态。</p>
<h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><p>原语是一些位于操作系统底层，最接近硬件的小程序。这些程序具有原子性，运行时间短且频繁执行。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用是操作系统为应用程序提供的接口，是为了避免应用程序直接访问内核态而采取的保护措施。</p>
<h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>中断一般与当前运行的程序无关，比如当设备完成IO操作时向处理机发出的结束中断，时间片用完发出的时钟中断。异常一般与程序相关，如地址越界、算术溢出等事件。</p>
<h2 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h2><p>现代操作系统的体系结构主要分为两种：大内核和微内核。大内核是将系统主要模块集中在内核态，提供高性能的系统服务。但随着系统日益复杂，操作系统规模也急剧增大，为此又提出了微内核，微内核在内核态中只保留了最基本的功能，其他不需要内核态关注的功能都移到了用户态中，降低了内核的复杂性。被移出内核的功能借助微内核进行通信，但微内核的一个问题是性能不如大内核，因为需要在内核态和用户态之间频繁切换，系统开销比较大。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-进程与线程</title>
    <url>/2020/06/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>本文是进程管理中的第一部分，进程管理的内容是操作系统的核心，也是考试和面试的重点内容，本文将对进程与线程相关的内容进行梳理。</p>
<a id="more"></a>

<h2 id="进程的概念及组成"><a href="#进程的概念及组成" class="headerlink" title="进程的概念及组成"></a>进程的概念及组成</h2><p>对于进程的定义有很多，下面给出几种典型的定义：</p>
<ul>
<li><p>进程是程序的一次运行过程。</p>
</li>
<li><p>进程是一个程序及其数据在处理机上顺序执行的活动。</p>
</li>
<li><p>进程是进程实体运行的过程，是系统进行资源分配和调度的独立单位。</p>
</li>
</ul>
<p>进程主要由程序段、数据段和PCB（进程控制块）组成，其中PCB是进程存在的唯一标识。</p>
<p>PCB一般包括程序ID（PID）、特征信息（表示是系统进程、用户进程还是内核进程）、进程状态（就绪、阻塞或运行）、优先级、资源分配清单和处理机相关信息。程序段是能被调度的代码段。数据段可以是待处理的原始数据，也可以是中间数据或结果数据。</p>
<h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><p>进程主要有五种状态，分别是运行态、就绪态、阻塞态、创建态和结束态，其中前三种为进程的基本状态。</p>
<ul>
<li><p>运行态。处理机运行进程时的状态，一般单处理机环境中，一个时刻最多只有一个进程在运行。</p>
</li>
<li><p>就绪态。就绪态是指进程等待处理机的状态，一旦得到处理机就立刻运行进程。</p>
</li>
<li><p>阻塞态。当进程交出处理机等待并使用资源（例如打印机）时的状态，此时即使处理机空闲也无法运行这个进程。</p>
</li>
<li><p>创建态。进程被创建但还没有转到就绪态时的状态。</p>
</li>
<li><p>结束态。进程需要结束，即将回收或释放资源时的状态。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200610190433769.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="进程间状态转换"></p>
<p>下面介绍一下三种基本状态的进程之间转换的情境。</p>
<ul>
<li><p>就绪态-&gt;运行态：当就绪态的进程分配到时间片后，就会进入运行态。</p>
</li>
<li><p>运行态-&gt;就绪态：当运行态的时间片用完或者有更高优先级的进程就绪时，当前进程会让出处理机资源，进入就绪态。</p>
</li>
<li><p>运行态-&gt;阻塞态：当进程请求某一资源的使用或等待某一事件的到来，会从运行态转到阻塞态。</p>
</li>
<li><p>阻塞态-&gt;就绪态：当进程等到了请求的事件或使用完请求的资源（如打印机）时则会转为就绪态。</p>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>进程可以创建另一个进程，创建者是父进程，被创建的进程是子进程。父进程为子进程提供资源。子进程运行结束后将资源还给父进程，父进程结束则所有子进程都会结束。</p>
<p>创建新进程的过程主要包括以下步骤：</p>
<ul>
<li><p>为新进程分配一个进程识别号，并申请一个空白的PCB，若申请失败则创建新进程失败；</p>
</li>
<li><p>为新进程分配资源（内存空间），若分配失败则创建新进程失败；</p>
</li>
<li><p>初始化PCB，包括初始化标志信息、处理机状态信息和处理机控制信息，并设置进程优先级；</p>
</li>
<li><p>若就绪队列可以插入新进程就将新进程插入就绪队列。</p>
</li>
</ul>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程终止的过程主要包括以下步骤：</p>
<ul>
<li><p>根据进程标识符检索PCB并读取进程的状态；</p>
</li>
<li><p>若进程处于运行状态则终止进程并将处理机资源分配给其他进程；</p>
</li>
<li><p>若当前进程有子进程则终止子进程；</p>
</li>
<li><p>将当前进程拥有的全部资源还给父进程或操作系统；</p>
</li>
<li><p>将该进程的PCB从队列中删除。</p>
</li>
</ul>
<h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p>进程阻塞是进程的一种主动行为，主要在等待某一事件完成、新数据尚未到达或无工作可做时发生。进程阻塞需执行阻塞原语，主动让出处理机，因此只有运行态可以转换成阻塞态。阻塞原语的执行过程如下：</p>
<ul>
<li><p>找到要被阻塞的进程的PCB；</p>
</li>
<li><p>为运行态的进程保护现场并将状态转为阻塞态，让出处理机资源；</p>
</li>
<li><p>将PCB插入相关事件的等待队列。</p>
</li>
</ul>
<p>进程的唤醒是一种被动行为，一般是进程期待的数据到达或事件完成后发生。进程的唤醒原语执行过程如下：</p>
<ul>
<li><p>在等待队列找到被唤醒的进程的PCB；</p>
</li>
<li><p>将该PCB移出并将其状态置为就绪态；</p>
</li>
<li><p>将PCB插入就绪队列，等待处理机调度该进程。</p>
</li>
</ul>
<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p>进程间的切换往往在内核态下发生，主要过程包括：</p>
<ul>
<li><p>保存处理机上下文，包括程序计数器和其他寄存器；</p>
</li>
<li><p>更新PCB信息；</p>
</li>
<li><p>将PCB移入就绪队列或阻塞队列；</p>
</li>
<li><p>切换到另一个进程运行，并更新其PCB;</p>
</li>
<li><p>更新内存管理的数据结构；</p>
</li>
<li><p>恢复处理机上下文。</p>
</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间通信主要有三种方式：共享存储、消息传递和管道通信。</p>
<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p><img src="https://img-blog.csdnimg.cn/20200611151401759.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="共享存储"></p>
<p>共享存储的原理很简单，就是一个进程将需要通信的数据放在共享空间里，另一个进程来共享空间中取出数据即可。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>消息传递系统是当今使用最广泛的进程通信方式，进程间的数据交换是以格式化的消息（message）为单位的。根据实现方式的不同，消息传递又可分为直接通信方式和间接通信方式。</p>
<p>直接通信方式是指发送进程直接将数据发送给接收进程，数据被插入接收进程的消息缓存队列中，接收进程从缓冲队列取出消息使用。</p>
<p><img src="https://img-blog.csdnimg.cn/20200611153905213.jpg#pic_center" alt="直接通信方式"></p>
<p>间接通信方式是指发送进程将消息发送到一个中间实体中，接收进程从中间实体取出消息并使用，这里的中间实体被称为信箱。间接通信方式的原理和消息队列（如RabbitMQ、RocketMQ、Kafka等）的原理一致，与直接通信方式相比，降低了进程间的耦合度。</p>
<p><img src="https://img-blog.csdnimg.cn/20200611155822940.jpg#pic_center" alt="间接通信方式"></p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>学习过Java NIO的同学应该对管道不陌生，管道就是用于连接一个读进程和一个写进程进行通信的一个共享文件，又名pipe文件。值得注意的是，管道中的数据都是一次性的数据，一旦被读进程使用过就管道就会将这部分数据丢弃。</p>
<p><img src="https://img-blog.csdnimg.cn/20200611164937936.jpg#pic_center" alt="管道通信"></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程和线程的比较"><a href="#进程和线程的比较" class="headerlink" title="进程和线程的比较"></a>进程和线程的比较</h3><p>线程可以被理解为“轻量级的进程”，提高了资源利用率和吞吐量，加大了系统并发能力。我们从下面几个角度来对比一下进程和线程之间的差异。</p>
<ul>
<li><p>调度。在传统操作系统中，进程是拥有资源的基本单位和独立调度、分派的基本单位。在引入线程的操作系统中，线程成为了调度和分派的基本单位，而进程是拥有资源的基本单位。同一进程中的线程的切换不会引起进程的切换，而不同进程的线程切换则会引起进程切换。</p>
</li>
<li><p>并发性。在引入线程的操作系统中，不仅进程可以并发执行，线程也可以并发执行，从而可以提高线程的吞吐量。</p>
</li>
<li><p>拥有资源。进程是拥有资源的基本单位，线程除了一些必须的资源外不拥有资源，但是线程可以使用所在进程的资源。</p>
</li>
<li><p>系统开销。系统开销方面，毫无疑问，进程一定比线程开销大。在创建和撤销进程时，系统需要为进程分配和回收资源；在进程切换时，进程需要保存当前进程的CPU环境，设置被调度进程的CPU环境。线程的切换开销则小了很多，只需要设置保存少量寄存器中的内容即可。Java中线程切换时，Java虚拟机会保存程序计数器中的内容。</p>
</li>
</ul>
<h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p>线程的实现主要分为用户级线程和内核级线程。用户级线程是由用户创建的线程，内核意识不到用户级线程的存在；内核级线程的管理由内核完成，内核为进程及其内部的线程维护上下文信息，调度也在内核基于线程架构的基础上上完成的。</p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>多线程模型是用户级线程和内核级线程结合的模型，一般有以下几种多线程模型：</p>
<ul>
<li><p>一对一模型。一对一模型将一个用户级线程映射到一个内核级线程中。优点是一个线程阻塞后，另一个线程可以继续执行，并发能力强。缺点是每个用户级线程都需要对应一个内核级线程，开销太大。</p>
</li>
<li><p>多对一模型。多个用户级线程对应一个内核级线程。优点是线程在用户空间管理，效率较高。缺点是一个线程使用内核服务时阻塞会导致整个进程阻塞。</p>
</li>
<li><p>多对多模型。多个用户级线程对应多个内核级线程，内核级线程数不大于用户级线程数。该模型集合了前两种方式的优点。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>不会吧不会吧，不会有人连线程池都没听说过吧</title>
    <url>/2020/08/06/%E4%B8%8D%E4%BC%9A%E5%90%A7%E4%B8%8D%E4%BC%9A%E5%90%A7%EF%BC%8C%E4%B8%8D%E4%BC%9A%E6%9C%89%E4%BA%BA%E8%BF%9E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%B2%A1%E5%90%AC%E8%AF%B4%E8%BF%87%E5%90%A7/</url>
    <content><![CDATA[<p>在上一篇文章中，我们介绍了创建线程的三种方法，但实际开发中如果需要频繁创建线程则不会使用前文说的那三种方法，而是选择使用线程池创建线程。使用线程池可以有效减少在手动创建线程过程中产生的开销，方便线程进行统一管理，提高系统资源利用率。</p>
<p>在阿里巴巴Java开发手册中也强制规定了要使用线程资源必须通过线程池创建，不允许在应用中自行显式创建线程。</p>
<a id="more"></a>

<p>下面介绍几种常见的线程池：</p>
<ul>
<li><p>newFixedThreadPool（固定大小的线程池）</p>
</li>
<li><p>newCachedThreadPool（可缓存线程的线程池）</p>
</li>
<li><p>newSingleThreadExecutor（单线程的线程池）</p>
</li>
<li><p>newScheduledThreadPool（定时及周期执行线程池）</p>
</li>
</ul>
<p>第一种是固定大小的线程池，下面给出该线程池的测试demo。设置固定的线程数为3，创建4个线程，第四个线程会在线程池中有空闲线程时调用该线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">			es.execute(() -&gt; &#123;</span><br><span class="line">				System.out.println(<span class="string">"固定大小的线程池在"</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()) +<span class="string">"创建了"</span> + Thread.currentThread().getName());</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		es.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是可缓存线程的线程池，这里可以开启任意多个线程（前提是不超过内存限制）。该线程池可以灵活回收空闲线程，如果线程池中没有足够线程就会创建一个新线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">			es.execute(() -&gt; &#123;</span><br><span class="line">				System.out.println(<span class="string">"可缓存线程的线程池在"</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()) +<span class="string">"创建了"</span> + Thread.currentThread().getName());</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		es.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种是单线程的线程池，线程池中仅有一个线程，严格按照先来先服务的原则进行代码执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">			es.execute(() -&gt; &#123;</span><br><span class="line">				System.out.println(<span class="string">"单线程的线程池在"</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()) +<span class="string">"创建了"</span> + Thread.currentThread().getName());</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		es.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四种是定时及周期执行线程池，用于设置定时及周期性任务。如下的代码会每隔1秒钟进行一次报时，3秒后关闭线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ScheduledExecutorService es = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">		es.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">"定时周期执行线程池为您报时："</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date())), <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		es.shutdown();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，比较不幸的是，阿里巴巴Java开发手册中明确指出上面四种线程池不允许使用，必须使用它们底层所使用的类ThreadPoolExcutor来创建线程池。</p>
<p>下面是ThreadPoolExecutor方法的具体内容，当然这是一个重载方法。我们选择参数最多的方法，一个参数一个参数的介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize</li>
</ul>
<p>首先是corePoolSize，这是线程池核心线程数，除非将<code>allowCoreThreadTimeOut</code>设置为true，否则默认核心线程将一直在线程池中存活。</p>
<ul>
<li>maximumPoolSize</li>
</ul>
<p>maximumPoolSize是线程池中的最大线程数，这里的最大线程数是指核心线程数与最大非核心线程数之和。</p>
<ul>
<li>keepAliveTime</li>
</ul>
<p>keepAliveTime用来表示非核心线程的存活时长。</p>
<ul>
<li>unit</li>
</ul>
<p>unit是非核心线程存活的时间单位，如秒、毫秒、小时等。</p>
<ul>
<li>workQueue</li>
</ul>
<p>用于在执行任务之前使用的队列。常见的队列有三种：<code>SynchronousQueue</code>、<code>LinkedBlockingDeque</code>和<code>ArrayBlockingQueue</code>。</p>
<ul>
<li>threadFactory</li>
</ul>
<p>线程工厂。</p>
<ul>
<li>handler</li>
</ul>
<p>使用特定策略处理无法处理的任务。常见的拒绝策略包括<code>AbortPolicy</code>、<code>CallerRunsPolicy</code>、<code>DiscardOldestPolicy</code>和<code>DiscardPolicy</code>。</p>
<p>下面详细介绍一下ThreadPoolExecutor的执行过程：</p>
<p>1.线程数低于corePoolSize时总是创建新线程来执行任务。<br>2.当线程数高于corePoolSize而低于maximumPoolSize时，如果是<code>SynchronousQueue</code>这样的队列，则检查有无空闲线程，有的话则分配空闲线程执行任务，否则创建新的线程。如果是<code>LinkedBlockingDeque</code>这样的队列，则将任务放入队列，这种情况下设置的<code>maximumPoolSize</code>是没有意义的。如果是<code>ArrayBlockingQueue</code>这种队列则会将任务入队，当队列满了就创建非核心线程来处理任务。<br>3.当队列满了且线程池达到了最大线程数，则任务会被拒绝策略处理。当采用<code>AbortPolicy</code>策略时会自动丢弃任务并抛出RejectedExecutionException异常，当采用<code>DiscardPolicy</code>策略时丢弃任务但不抛出异常，当采用<code>DiscardOldestPolicy</code>策略时会丢弃队列最前面的任务并尝试重新提交任务，当采用<code>CallerRunsPolicy</code>策略时，任务不会被抛弃，但不是由线程池中的线程执行，而是由调用线程执行。</p>
<p>现在我们基本把ThreadPoolExecutor的原理讲完了，话题回到前面的四种Executors创建的线程池。为什么阿里巴巴Java开发手册不允许使用它们呢？我们来看一下这四种线程池底层的实现源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先看一下<code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>的源码，它们使用的队列是<code>LinkedBlockingQueue</code>，这种队列前面没讲到的点是它默认的队列容量是<code>Integer.MAX_VALUE</code>，这就导致当我们需要使用线程池完成耗时任务但一直源源不断有新的任务进来时可能导致OOM（内存溢出）。接着我们看<code>newCachedThreadPool</code>和<code>newScheduledThreadPool</code>这两种线程池，ScheduledThreadPoolExecutor是ThreadPoolExecutor的子类，所以根据上面的代码可以看出这两种线程池都会能创建最多<code>Integer.MAX_VALUE</code>个线程，这必然也会有OOM的风险。</p>
<p>那么正确创建线程池的方式是怎样的呢？下面我们用一个demo演示一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">50</span>, </span><br><span class="line">		<span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">		es.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"成功执行任务"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码我们指定了核心线程数和最大线程数，并且将任务队列设置为固定大小的ArrayBlockingQueue，当然实际参数应该根据具体的需求进行调整。我故意设置了超出线程池处理能力的任务数。执行结果如下，抛出了RejectedExecutionException异常，不过异常总好过错误。</p>
<p><img src="https://img-blog.csdnimg.cn/20200809101530922.png#pic_center" alt=""></p>
<p>以上就是本文的全部内容，喜欢的朋友欢迎关注我的公众号：<strong>SKY技术修炼指南</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2020/09/13/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>本文介绍一下Java多线程中比较重要的部分——Java内存模型，也就是我们说的JMM。</p>
<a id="more"></a>

<p>很多人会把Java内存模型和Java内存区域弄混，Java内存区域又叫运行时数据区，我们之前在介绍Java虚拟机的文章中也已经讲过了，有兴趣的朋友可以翻一翻我之前的文章。但是这两个概念也并不是完全没有关系，我们先简单回顾一下Java内存区域的概念。Java内存区域主要分为线程共享的堆和方法区以及线程私有的程序计数器、虚拟机栈和本地方法栈。</p>
<p><img src="https://img-blog.csdnimg.cn/20200521144716505.jpg#pic_center" alt=""></p>
<p>下图展示了Java内存模型的结构。主内存是多个线程共享的区域，对应上面的Java内存区域中的堆区和方法区，本地内存为线程所私有，对应了Java内存区域的程序计数器、虚拟机栈和本地方法栈。当然，Java内存模型本质上只是抽象的概念。</p>
<p><img src="https://img-blog.csdnimg.cn/2020091321254596.png#pic_center" alt=""></p>
<p>上图的线程A和线程B都拥有各自的本地内存，本地内存相当于是每个线程将主存中的变量存在本地的一个副本。因为CPU的速度远远高于主存，因此本地内存的作用是缓解CPU与主存之间速度不匹配的矛盾。但本地内存也因此带来了一些问题，比如多个线程同时操作一个变量，实际上操作的都是本地内存中的变量而非主存中的，因此一个线程修改数据后另一个线程并不能感知到修改的数据，这就带来了线程安全问题。</p>
<p>因此，为线程提供内存的可见性保障就成了比较重要的问题。这里必须要提一下Java中的<code>volatile</code>关键字，它的一个重要特征就是能够保证内存可见性。下面这个图演示了线程A和线程B通过<code>volatile</code>进行线程通信的过程。</p>
<p><img src="https://img-blog.csdnimg.cn/20200913221347651.png#pic_center" alt=""></p>
<p>当线程A往本地内存中写入一个变量<code>x=1</code>时，会同时将变量刷新到主存中去，当线程B在本地内存中获取<code>x</code>的值时，会从主存中将<code>x</code>同步到线程B的本地内存，然后读取本地内存。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于HashMap，你想知道的可能都有</title>
    <url>/2020/07/08/%E5%85%B3%E4%BA%8EHashMap%EF%BC%8C%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E5%8F%AF%E8%83%BD%E9%83%BD%E6%9C%89/</url>
    <content><![CDATA[<p>在现在的互联网大厂面试中，HashMap几乎是必问的知识点。因此本文对HashMap进行系统性的总结，将HashMap常见的知识点都整理出来。</p>
<a id="more"></a>

<p>前面铺垫了两篇红黑树的文章，终于进入这篇HashMap了。如果有不知道什么是红黑树的同学，先去看一下我前面讲红黑树的文章。<br><a href="https://mp.weixin.qq.com/s/znClfHriql7LOUi_eRq5lA" target="_blank" rel="noopener">本科数据结构课程的漏网之鱼-红黑树（上）</a><br><a href="https://mp.weixin.qq.com/s/38M5RAFaYTIabIU3ovK0Ew" target="_blank" rel="noopener">本科数据结构课程的漏网之鱼-红黑树（下）</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>相信大家之前或多或少都接触过HashMap，这是一种用来存放键值对的数据结构。它实现了Map接口，是最常用的Java容器之一。在JDK7及之前版本中，HashMap实现方式都是通过<code>数组+链表</code>，而JDK8开始，HashMap底层通过<code>数组+链表+红黑树</code>的数据结构实现。下面就将开始详细介绍这部分内容。</p>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>在JDK7及之前的版本中，HashMap都是通过数组+链表实现的，大致结构如下图。</p>
<p><img src="https://img-blog.csdnimg.cn/2020070817345065.png#pic_center" alt="JDK7及之前的HashMap底层结构"></p>
<p>然而这种数据结构有一定局限性，当某个链表特别长的话，搜索效率就大大降低，因此，JDK8中引入了红黑树，目的就是减少查找次数。当链表长度大于阈值（默认为8）时，就会转换成红黑树。</p>
<p><img src="https://img-blog.csdnimg.cn/20200708172215166.png#pic_center" alt="JDK8的HashMap底层结构"></p>
<p>在JDK7中，插入结点都叫Entry，这结构就是散列表中常见的“拉链法”。而在JDK8中，结点变成了Node。</p>
<h2 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是JDK8中截取的插入结点的核心源码，我们一步一步分解上面的源码。首先看到<code>put</code>方法里面对key进行了一次hash运算，传入到<code>putVal</code>中帮助计算下标值，接着往下看<code>putVal</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>

<p>tab是数组名，p是待插入结点，n是数组长度，这就很明朗了。如果是空数组，那么会进入这个判断语句中，此时tab被<code>resize</code>方法赋值后，取tab的长度给n。这里先不展开介绍<code>resize</code>方法，只需知道tab被赋的初始长度是16。接着往下看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>上面这段代码就有意思了，重点在<code>(n - 1) &amp; hash</code>。我们前面说到hash是通过<code>hash(key)</code>计算得到的，这里和<code>n-1</code>进行按位与运算实际上等同于<code>hash % n</code>。在HashMap中，数组的长度n一定是2的幂。以n=16为例，n-1的值就是15。我们随便写一个hash值与15进行按位与运算，如下图。</p>
<p><img src="https://img-blog.csdnimg.cn/20200709190427437.jpg#pic_center" alt="(n - 1) &amp; hash运算"></p>
<p>我们可以发现15的二进制只有后四位是1，前面全部都是0，进行按位与运算后的结果只与hash的后四位相关，前面全部都是0，也就验证了我们前面所说的<code>(n - 1) &amp; hash</code>等效于<code>hash % n</code>，并由此计算出数组下标值i。很显然如果在数组中下表为i的位置为空，就创建一个新结点放入数组中。</p>
<p>继续往下看是一个else语句，也就是数组的下标i位置已经有值了，我们需要解决hash冲突。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">    ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br></pre></td></tr></table></figure>

<p>上面这段代码描述了存入一个已存在的key值将会将原来的结点替换成新的结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br></pre></td></tr></table></figure>

<p>这段代码是指如果当前这个下标的结点是红黑树结点，那么就按照红黑树的插入方式插入结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还剩这一种情况就是当结点是链表结点时，顺着链表从头开始往后找，如果找到最后没有相同key值的结点，就将结点插到链表末尾，插入后大于等于8个结点，就把链表转成红黑树；如果在链表中找到了key相同的结点，就替换原来的结点。在JDK8中，插入链表的方式是采用尾插法，而在JDK7中是采用头插法。而在多线程环境下，头插法有可能会出现环形链表。</p>
<p><img src="https://img-blog.csdnimg.cn/20200709212719737.png#pic_center" alt="头插法导致环形链表"></p>
<p>但是这并不意味着使用尾插法在多线程环境下就是安全的，因为<code>put/get</code>方法没有加同步锁，因此无法确保线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    V oldValue = e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码用于替换结点后返回原结点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">++modCount;</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>最后这段代码主要用于收尾，修改次数+1，如果键值对个数超过了阈值就进行扩容。</p>
<h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>当HashMap中键值对个数超过了阈值时，就会启动扩容机制，而这里的所谓“阈值”指的就是数组长度与负载因子的乘积。扩容机制的核心源码是通过<code>resize</code>方法实现的，前面我们提到过这个方法，但是没有展开讲它的细节，我们这里讲一下具体的代码细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码比之前的代码片段更长，我们还是一部分一部分地看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"><span class="keyword">int</span> oldThr = threshold;</span><br><span class="line"><span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这部分没什么好说的，oldTab就是扩容前的数组，oldCap和oldThr分别是扩容前的容量和扩容前的阈值，如果是之前没有存放过元素，那么这两个属性的初始值都是0，newCap和newThr是扩容后的数组长度和阈值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是扩容前数组容量大于0的情况下，如果扩容前的数组容量已经达到了最大限制，那么无法继续扩容，否则新数组容量是原来的两倍，若是扩容后的容量满足要求则阈值也变为原来的二倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line"><span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果扩容前容量不大于0，而扩容前的阈值大于0，那么将新的容量设为旧的阈值。如果阈值和容量都不大于0（比如HashMap初始状态）那么将新的容量设置为16，新的阈值设置为12。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是给新阈值赋值，也没什么好说的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threshold = newThr;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab;</span><br></pre></td></tr></table></figure>

<p>这段代码就是为扩容以后做准备了，申请一段新的内存空间，赋值给数组。</p>
<p>最后一部分的代码比较长，我们说一下基本思路。遍历扩容前的所有结点，并对其进行ReHash。为什么要进行ReHash呢？我们回顾一下算出插入位置的方法：<code>(n - 1) &amp; hash(key)</code>。数组长度变了，那么插入的位置自然也就变了，因此我们需要进行ReHash。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>HashMap是线程不安全的，尽管JDK8改进了之前JDK7在多线程环境下可能出现循环链表的问题，但这并不意味着HashMap就线程安全了。常见的替代HashMap的线程安全方案有HashTable和ConcurrentHashMap两种集合，但是HashTable在并发能力方面并不理想，因此使用很少。</p>
<h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><p>为什么开发人员要把默认负载因子设置为0.75呢？因为根据泊松分布，使用0.75作为负载因子，链表元素达到8个是极小的概率。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机-经典垃圾收集器介绍</title>
    <url>/2020/06/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>在前面的文章中，我们提到了几种常见的垃圾收集算法，今天咱们来说一说商用Java虚拟机中经典的垃圾收集器。</p>
<a id="more"></a>

<h2 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><p>我们首先介绍三种新生代的垃圾收集器，分别是Serial收集器、ParNew收集器和Parallel Scavenge收集器。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="https://img-blog.csdnimg.cn/20200606170438483.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="Serial收集器垃圾收集过程"></p>
<p>Serial收集器是最古老的垃圾收集器，曾经是新生代垃圾收集的唯一选择。这是一种单线程的垃圾收集器，采用标记-复制算法，在进行垃圾收集时，所有的工作线程都会停止等待垃圾收集完成，也就是所谓的“Stop the world”。对于服务器来说，可能过长的暂停是不可接受的，但是对于短暂的暂停时间不敏感的客户端其实仍然是简单高效的选择。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><img src="https://img-blog.csdnimg.cn/20200606192934365.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="ParNew收集器垃圾收集过程"></p>
<p>ParNew收集器可以被看作是Serial收集器的多线程版本，比起Serial收集器并没有太大创新，只是把GC过程的单线程改成了多线程，同样也是采用复制算法。这里我们需要补充一点，当在单核CPU的场景下，由于线程切换必然会产生一定的开销，因此，在这种情况下，ParNew收集器的效率是不如Serial收集器的。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>同样的，Parallel Scavenge收集器也是多线程版本的收集器，因此垃圾收集过程和上述的ParNew收集器很类似。与CMS等关注工作线程停顿时间（提高用户体验）不同，Parallel Scavenge收集器的特点是非常关注吞吐量的大小（高效利用CPU），吞吐量的计算公式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">吞吐量&#x3D;工作线程运行时间&#x2F;CPU总运行时间</span><br></pre></td></tr></table></figure>

<h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><p>几种常见的老年代垃圾收集器分别是Serial Old收集器、Parallel Old收集器和CMS收集器。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>单从名字来看，Serial Old收集器是Serial收集器的老年代版本，事实也确实如此，这款收集器是单线程，采用标记-整理算法的收集器。在JDK 5及以前的JDK中，Serial Old收集器常常与Parallel Scavenge收集器一同使用。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>与Serial Old收集器类似，Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法收集垃圾。这款垃圾收集器是JDK 6才开始出现的，在此之前都是Serial Old收集器常常与Parallel Scavenge收集器搭配使用，但是这样的话，尽管新生代的垃圾收集是多线程的，但是老年代却是单线程的，因此实际上吞吐量可能并不是很高。Parallel Old收集器出现以后，配合Parallel Scavenge收集器才真正是高吞吐量的垃圾收集。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS是一款划时代的垃圾收集器，它通过较短的停顿时间进行垃圾收集，是HotSpot的第一款真正意义上的并发收集器（用户线程和GC线程并发工作），还是一种“边污染边治理”的收集器。CMS收集器的垃圾收集分为四个步骤：</p>
<ul>
<li><p>初始标记</p>
</li>
<li><p>并发标记</p>
</li>
<li><p>重新标记</p>
</li>
<li><p>并发清除</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200607213045562.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="CMS收集器垃圾收集过程"></p>
<p>其中，初始标记和重新标记都需要停止其他工作线程。初始标记时利用可达性分析算法从GC Roots出发进行标记，整个过程耗时非常短，而重新标记是对并发标记过程中工作线程产生的垃圾进行收集。最后是并发-清除过程，由于不需要移动对象，因此GC线程与工作线程并发运行。</p>
<p>在整个CMS收集器收集垃圾的过程中，初始标记和重新标记的耗时是最短的，因此CMS是一款非常优秀的垃圾收集器。但是这款收集器就没有缺点吗？答案是有的。下面总结了几条CMS收集器的缺点：</p>
<ul>
<li><p>由于CMS采用标记-清除算法，因此会产生大量的内存碎片，将来需要分配大内存给某个对象时，可能没有足够的内存空间。</p>
</li>
<li><p>CMS收集器对处理器资源敏感，并发过程中CMS收集器的线程实际上是占据了一部分处理器资源的，因此造成吞吐量在一定程度上的下降。</p>
</li>
<li><p>难以处理并发清除阶段产生的“浮动垃圾”。在并发清理阶段尽管会回收部分垃圾，但是此时工作线程也在运行，还在产生一些垃圾，但这些垃圾因为没有被标记，因此是不可回收的。这时如果工作线程分配新的对象而没有足够的内存空间时，就会发生“并发失败”（Concurrent Mode Failure），此时虚拟机将会把CMS收集器替换成为Serial Old收集器，并冻结工作线程。</p>
</li>
</ul>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1收集器是一款面向服务器端的垃圾收集器，服务器端的多CPU和大容量内存能够满足G1收集器对于缩短GC停顿时间的需求。G1也采用分代理论，但是这些不再是之前固定大小和位置了，而是将堆内存划分为一个个小的内存块，每个内存块可以根据需求进行划分，下面的分区中Humongous区是用于存放大对象的区域。</p>
<p><img src="https://img-blog.csdnimg.cn/20200607162646881.png?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="G1收集器分区图"></p>
<p>G1收集器的垃圾收集过程也分为4个步骤：</p>
<ul>
<li><p>初始标记。初始标记与CMS类似，需要进行“Stop the world”，但是是借着Minor GC的过程进行的，因此没有额外的耗时。这个过程标记GC Roots可以关联的对象，然后修改TAMS（Top at Mark Start）的指针，指针划分每一个区域中的一部分空间用于并发回收过程中的新对象分配。</p>
</li>
<li><p>并发标记。从GC Root开始对堆中对象进行可达性分析，找出要回收的对象，并且需要处理原始快照（SATB）记录的在并发时引用变动的对象。</p>
</li>
<li><p>最终标记。需要“Stop the world”并进行并发标记遗留的SATB对象的处理。</p>
</li>
<li><p>筛选回收。这里根据用户期望的停顿时间指定回收计划，将决定回收的区域的存活的对象复制到新的区域中，并清空旧的区域。这里同样暂停所有工作线程。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200607213129279.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="G1收集器垃圾收集过程"></p>
<p>与CMS收集器的标记-清除不同，G1收集器宏观上看使用标记-整理算法，从局部来看又是使用的标记-复制算法。可以由用户指定期望的停顿时间是G1相较CMS的一个较大的优势，但是这里的停顿时间必须切合实际，因为停顿时间一定是有一个下限的，因此过小的停顿时间可能难以达到预期，甚至引发Full GC降低系统性能。</p>
<h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>这些年JDK版本迭代速度较快，涌现了一些非常优秀的垃圾收集器，本文只是介绍了一些经典的垃圾收集器，后续还会有一些优秀的收集器，比如Shenandoah收集器和ZGC收集器，这两款都是非常优秀的低延迟垃圾收集器，在今年的春招中有些公司已经开始问到相关的问题了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机-判断对象是否存活算法与对象引用</title>
    <url>/2020/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>在之前的文章中我们谈到过Java内存区域的概念，我们知道Java中的对象一般存放在堆中，但是总不能让这些对象一直占着内存空间，这些对象最终都会被回收并释放内存，那么我们如何判断对象已经成为垃圾呢？这篇文章会提出两种算法解决这个问题。另外，本文还要谈一谈对象引用相关的知识，这在面试中也是经常被问到的问题。</p>
<a id="more"></a>

<h2 id="判断对象是否存活算法"><a href="#判断对象是否存活算法" class="headerlink" title="判断对象是否存活算法"></a>判断对象是否存活算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数算法的原理比较简单，<strong>在对象中添加一个引用计数器，当有一个引用指向一个对象时，这个对象的引用计数器会加1，当引用不再指向对象时，引用计数器便减1。当引用计数器的值为0时，说明对象已经成为垃圾。</strong><br>引用计数算法的优点是算法非常简单，效率也比较高。但是Java并没有使用这种算法管理内存，这是为什么呢？我们先来看看下面这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Obj obj1 = <span class="keyword">new</span> Obj();</span><br><span class="line">		Obj obj2 = <span class="keyword">new</span> Obj();</span><br><span class="line">		obj1.instance = obj2;</span><br><span class="line">		obj2.instance = obj1;</span><br><span class="line">		obj1 = <span class="keyword">null</span>;</span><br><span class="line">		obj2 = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Obj instance;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Obj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下上面这段代码，两个对象<code>obj1</code>和<code>obj2</code>的<code>instance</code>分别指向对方，造成了循环引用。即便最后<code>obj1</code>和<code>obj2</code>都置为空，但它们的<code>instance</code>还是指向对方，如果我们使用这种算法，这两个对象势必无法回收，最终造成内存泄漏。因此，Java没有选择使用引用计数算法管理内存。</p>
<h3 id="可达性分析算法（根搜索算法）"><a href="#可达性分析算法（根搜索算法）" class="headerlink" title="可达性分析算法（根搜索算法）"></a>可达性分析算法（根搜索算法）</h3><p>主流的商用编程语言（Java、C#以及上古语言Lisp）都是用这种算法进行对象是否存活的判断。</p>
<p><img src="https://img-blog.csdnimg.cn/2020052511014842.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="利用可达性分析算法判定对象是否可回收"></p>
<p>根搜索算法<strong>利用GC Roots作为起始节点集，从这些节点开始向下搜索，凡是能够到达的节点都是存活节点，不能到达的节点都不再会被使用，这些节点的对象都可以被回收。</strong><br>Java技术体系中可以作为GC Roots的对象有以下几种：</p>
<ul>
<li><p>虚拟机栈（栈帧的本地变量表）中引用的对象</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>方法区中常量引用的对象</p>
</li>
<li><p>本地方法栈中JNI（及native方法）引用的对象</p>
</li>
<li><p>虚拟机内部的引用，比如基本数据类型对应的Class对象，一些常驻的异常对象（如NullPointerException、OutOfMemoryError）等，还有类加载器。</p>
</li>
<li><p>被同步锁（synchronized）持有的对象</p>
</li>
<li><p>反映Java虚拟机内部情况的JMXBean、JVMTI注册的回调，本地代码缓存等</p>
</li>
</ul>
<p>另外，需要补充的是，即便被可达性分析算法标记为不可达对象，这些对象也未必一定会被回收。事实上，被标记为不可达对象后，这个对象还需要经历第二次标记才可能会被宣布正式死亡。当第一次标记以后，会判断对象有没有必要执行<code>finalize()</code>方法。当对象没有覆盖<code>finalize()</code>方法或已经被虚拟机调用过的话，就被判定没有必要再继续执行了。当有必要执行<code>finalize()</code>方法时，这些对象会被放在名为<code>F-Queue</code>的队列中，随后虚拟机会创建一个线程去执行队列中的对象的<code>finalize()</code>方法。如果这些对象在收集器对<code>F-Queue</code>中对象标记前在<code>finalize()</code>方法中重新与引用链上的对象建立关系，比如将自己赋值给某个类变量就可以移出回收集合，免除被回收的命运。</p>
<h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><p>谈到引用，不得不提到前几天的考研复试，我的一位学弟在复试过程中被问到Java中有哪些引用，这几种引用有什么区别。被问到这道题时，他一时语塞，没有回答上来。不过好在没有因为这道题受到影响。今天我们就来谈一谈Java中的四种引用。</p>
<ul>
<li><p>强引用。强引用是我们平时使用最多的引用方法。<code>Object obj = new Object()</code>这就是一个典型的强引用实例，只要强引用关系还存在，即使系统内存不足，也不会回收这些对象。</p>
</li>
<li><p>软引用。软引用用来描述一些还有用，但不是必须的对象，使用<code>SoftReference</code>类来实现软引用。当系统内存不足时，会回收软引用关联的对象。</p>
</li>
<li><p>弱引用。弱引用通过<code>WeakReference</code>类来实现，即使内存充足，下一次垃圾收集时，弱引用对象也会被回收。</p>
</li>
<li><p>虚引用。虚引用又称“幽灵引用”或“幻影引用”，是最弱的一种对象引用，它使用<code>PhantomReference</code>类来实现。虚引用的作用是在关联的对象被回收时能收到一个系统通知。</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）<br><a href="https://next.xuetangx.com/learn/THU08091000252/THU08091000252/1511981/video/1318509" target="_blank" rel="noopener">学堂在线-JAVA程序设计进阶</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>本科数据结构课程的漏网之鱼-红黑树（下）</title>
    <url>/2020/06/26/%E6%9C%AC%E7%A7%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%9A%84%E6%BC%8F%E7%BD%91%E4%B9%8B%E9%B1%BC-%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>红黑树删除节点的操作与插入操作相比难度大大提高，以至很多博客讲的很不细致，但是为了内容的完整性，还是决定尝试写一下这篇红黑树删除节点的文章。</p>
<a id="more"></a>

<p>在正式开始介绍红黑树的删除操作之前，我们先来介绍一下普通的二叉搜索树的删除节点操作。</p>
<h2 id="二叉搜索树删除节点"><a href="#二叉搜索树删除节点" class="headerlink" title="二叉搜索树删除节点"></a>二叉搜索树删除节点</h2><p>二叉搜索树删除节点的基本情况有三种：</p>
<ul>
<li>当待删除节点是叶子节点时，直接删除这个节点即可。</li>
<li>只有一个子节点，用子节点代替待删除节点。</li>
<li>有两个子节点，把左子树中的最大节点或右子树中的最小节点替代待删除节点。</li>
</ul>
<h2 id="红黑树删除节点"><a href="#红黑树删除节点" class="headerlink" title="红黑树删除节点"></a>红黑树删除节点</h2><p><img src="https://img-blog.csdnimg.cn/20200626211831254.jpg#pic_center" alt=""></p>
<p>重点来了，由于删除的节点不同，可能会产生很多情况。但由于红黑树本身就是一棵二叉搜索树，因此在调整的过程中还是会遵循一些二叉搜索树的规则的。<br>以下对红黑树删除节点的内容分步骤进行，共有三步，大家需要耐心看完。</p>
<p><strong>步骤一：待删除节点有两个非空子节点</strong></p>
<p>这种情况下需要转化成待删除节点只有一个孩子或者没有孩子的情况。下图中被框住的节点代表待删除节点，三角形代表任意形态的子树。</p>
<p><img src="https://img-blog.csdnimg.cn/20200630103035126.jpg#pic_center" alt=""></p>
<p>在上图中，节点8是待删除的节点，由于它有两个孩子，我们按照普通的二叉搜索树的思路将节点8中序遍历的后一个节点10用来替换这个节点。</p>
<p><img src="https://img-blog.csdnimg.cn/20200630103424790.jpg#pic_center" alt=""></p>
<p>现在待删除的节点变成了原来的节点10，下面进行步骤二的操作。</p>
<p><strong>步骤二：待删除节点只有一个非空子节点或两个空节点</strong></p>
<ul>
<li>情况1：待删除节点是红色，子节点是黑色。这种情况下直接用子节点代替待删除节点就可以。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200630112215670.jpg#pic_center" alt=""></p>
<ul>
<li>情况2：待删除节点是黑色，子节点是红色。这种情况先将子节点替换待删除节点，再将子节点变色。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200630111941170.jpg#pic_center" alt=""></p>
<ul>
<li>情况3：待删除节点和子节点都是黑色。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200630113343357.jpg#pic_center" alt=""></p>
<p>显然用子节点代替父节点的话，这条路径上的黑色节点就少了一个，不满足红黑树的性质5（从任一节点出发到每个叶子节点都包含相同数量的黑色节点），这时我们需要进入步骤三。</p>
<p><strong>步骤三：待删除节点和其子节点均为黑色</strong></p>
<p>这一步就比较复杂了，可以分为6种情况，下面我们一一介绍。以下图片均是已经删除节点的图片，可以理解删除的节点是节点12的父节点，节点13（如果存在）的左孩子节点。</p>
<ul>
<li>情况1：节点12是根节点。这种情况不需要操作，因为在这种情况下没有任何违反红黑树的任何性质。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200630135026632.jpg#pic_center" alt=""></p>
<ul>
<li>情况2：节点12的父亲、兄弟、侄子节点都是黑色。在这种情况下，将兄弟节点变成红色，这样从节点13开始到任何叶子节点的黑色节点数都相等了。但是如果节点13不是根节点红黑树又不平衡了，我们让节点13继续扮演之前节点12的角色，递归进行步骤三的操作即可。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200630140439974.jpg#pic_center" alt=""></p>
<ul>
<li>情况3：节点12的父亲和侄子节点都是黑色，兄弟节点是红色。首先将节点12和节点13颜色互换，然后节点13进行左旋操作。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200630145004469.jpg#pic_center" alt=""></p>
<p>看到这里有人会疑惑，这不一样吗？节点12的那条路径上还是差一个黑色节点。别急，这是的情况3转变成了以下三种情况之一了。</p>
<ul>
<li>情况4：节点12的父亲节点是红色，兄弟、侄子节点是黑色。这种情况较为简单，将兄弟节点和父亲节点都变色即可。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200630145748484.jpg#pic_center" alt=""></p>
<ul>
<li>情况5：节点12的父节点颜色随意，兄弟节点15是黑色的右孩子，侄子节点16是红色的右孩子。这种情况需要首先对节点13进行左旋，然后对节点13、节点15颜色互换，节点16变成黑色。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200630162047348.jpg#pic_center" alt=""></p>
<ul>
<li>情况6：节点12的父节点颜色随意，兄弟节点是黑色的右孩子，侄子节点分别是红色的左孩子和黑色的右孩子。将节点15进行右旋后节点14变成了节点12的右兄弟节点。接着把节点14和节点15互换颜色，这时眼熟吗？就是上面的情况5，然后按照情况5的方式调整即可。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200630164553608.jpg#pic_center" alt=""></p>
<p>至此，红黑树删除操作的全部过程就已经介绍完毕了，如果没有看懂的朋友可以结合下面的实战多看几遍。</p>
<h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><p>光说不练假把式，接下来我们来一个完整的删除实例操练一下。</p>
<p><img src="https://img-blog.csdnimg.cn/20200630170616148.jpg#pic_center" alt=""></p>
<p>这里待删除节点是17，按照步骤一，该节点有两个非空子节点。我们将25复制到17的位置上，现在问题就转化成为删除原来的节点25了，按照步骤二，我们把空节点替换上去。</p>
<p><img src="https://img-blog.csdnimg.cn/20200630171732609.jpg#pic_center" alt=""></p>
<p>这时被框起来的部分是不是就是步骤三中的情况6的镜像？我们按照这种情况进行一波操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20200630180913105.jpg#pic_center" alt=""></p>
<p>这个时候就变成了步骤三中的情况5，我们继续按照前面说的方式调整。</p>
<p><img src="https://img-blog.csdnimg.cn/2020063018162092.jpg#pic_center" alt=""></p>
<p>到这里所有的调整就结束了。红黑树的删除部分很难理解，各位可以把上面的内容多看几遍。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>本科数据结构课程的漏网之鱼-红黑树（上）</title>
    <url>/2020/06/22/%E6%9C%AC%E7%A7%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E7%9A%84%E6%BC%8F%E7%BD%91%E4%B9%8B%E9%B1%BC-%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>在我大学的时候，就曾经从参加面试的学长那里知道红黑树这种数据结构，但是经过我的观察，绝大部分的本科数据结构课程里都没有这部分内容。本文将介绍这种被本科教学体系遗弃，但却常常被工作面试中提到的数据结构，并且为后面的HashMap的内容做铺垫。</p>
<a id="more"></a>

<h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><p>首先需要明确的是，红黑树是一棵<strong>二叉搜索树</strong>，如果不了解二叉搜索树的朋友可以先去了解一下。这里想到了本人在研究生复试的时候被问到什么是二叉搜索树，一时竟然没想起来。</p>
<p><img src="https://img-blog.csdnimg.cn/20200623144444818.png#pic_center" alt=""></p>
<p>下面是一棵典型的红黑树，我们可以看到这颗红黑树的确是一棵二叉搜索树。</p>
<p><img src="https://img-blog.csdnimg.cn/20200623155717535.jpg#pic_center" alt="红黑树"></p>
<p>一般来说，红黑树具有以下5个性质：</p>
<ul>
<li><p>节点由红色和黑色组成</p>
</li>
<li><p>且根节点是黑色</p>
</li>
<li><p>所有的叶子节点都是黑色</p>
</li>
<li><p>根节点到叶子节点的路径上不可能出现两个连续的红色节点</p>
</li>
<li><p>从任一节点出发到每个叶子节点都包含相同数量的黑色节点</p>
</li>
</ul>
<h2 id="红黑树的查找"><a href="#红黑树的查找" class="headerlink" title="红黑树的查找"></a>红黑树的查找</h2><p>因为红黑树是一棵二叉搜索树，所以同样具有二叉树的性质：左子树的所有节点都小于当前节点的值，右子树的所有节点都大于当前节点的值。所以，查找节点的算法就很简单了，我们来了解一下查找的流程。</p>
<p><img src="https://img-blog.csdnimg.cn/20200623151509296.png#pic_center" alt="红黑树查找流程"></p>
<h2 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><p>介绍红黑树的插入之前，先讲一下红黑树的三种调整方式：<strong>变色</strong>、<strong>左旋</strong>和<strong>右旋</strong>。变色很好理解，红色变黑色，黑色变红色，主要是左旋和右旋，我在网上找到一张图，很好的解释了左旋和右旋的含义。</p>
<p><img src="https://img-blog.csdnimg.cn/20200623161819607.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="左旋与右旋"></p>
<p>下面开始进入难点——红黑树的插入。待插入的节点是红色的，因为如果插入的节点是黑色，原来已经平衡的红黑树一定会不平衡，也就一定会进行调整。</p>
<p><strong>情况一：红黑树为空</strong></p>
<p>当红黑树为空的情况下，一目了然，直接插入，然后将节点变成黑色，是不是就符合5个性质了？</p>
<p><strong>情况二：插入节点的父节点是黑色</strong></p>
<p>直接插入节点即可，因为插入的节点是红色的，所以并不影响红黑树的平衡。</p>
<p><strong>情况三：插入节点的父节点和叔叔节点是红色</strong></p>
<p>分析一下这种情形，由于插入节点的父节点和叔叔节点都是红色，所以插入节点的祖父节点一定是黑色，因为不可能出现父子节点均为红色的情形。以前面的那棵红黑树为例，我们试着向里面插入一个值为21的节点。插入后的情形：</p>
<p><img src="https://img-blog.csdnimg.cn/20200623222028640.jpg#pic_center" alt="情况三的第一次调整"></p>
<p>结束了吗？没有。22和21是两个连续的红色节点，需要进行调整。插入节点的父节点和叔叔节点都是红色，因此将这两个节点变黑。</p>
<p><img src="https://img-blog.csdnimg.cn/2020062322291227.jpg#pic_center" alt="情况三的第二次调整"></p>
<p>再仔细观察一下，好像是可以了，但是尝试从根节点到叶子节点，不是每条路径上的黑色节点数都是相同的。再把插入节点的祖父节点25改成红色。</p>
<p><img src="https://img-blog.csdnimg.cn/20200624091332271.jpg#pic_center" alt="情况三的第三次调整"></p>
<p>17和25又是连续的红色节点了，这时把25当作新插入的节点，是不是回到了这种情况开始的状态？这时，给8和17变成黑色就可以满足所有的性质。</p>
<p><img src="https://img-blog.csdnimg.cn/2020062414045744.jpg#pic_center" alt="情况三的第四次调整"></p>
<p><strong>情况四：插入节点的父节点是红色，叔叔节点是黑色或缺少，插入节点是父节点的左子节点，父节点是祖父节点的左子节点</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200624152342709.jpg#pic_center" alt="情况四"></p>
<p>要在上图插入一个值为1的节点，这时会满足情况四。我们看一下插入这个节点以后的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20200624152830533.jpg#pic_center" alt="情况四插入节点后"></p>
<p>显然这里不满足不能有两个连续红色节点的性质，我们绕节点13进行右旋。</p>
<p><img src="https://img-blog.csdnimg.cn/20200624153529403.jpg#pic_center" alt="情况四的第一次调整"></p>
<p>接下来对8和13变色，就调整完成了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200624153742773.jpg#pic_center" alt="情况四的第二次调整"></p>
<p><strong>情况五：插入节点的父节点是红色，叔叔节点是黑色或缺少，插入节点是父节点的右子节点，父节点是祖父节点的左子节点</strong></p>
<p>最后一种情况了，我们还是使用情况四的初始状态，往里面插入一个值为10的新节点。</p>
<p><img src="https://img-blog.csdnimg.cn/20200624154816264.jpg#pic_center" alt="情况五插入节点后"></p>
<p>我们对节点8通过一次左旋交换插入节点和其父节点的位置，大家看一下是不是变成了情况四？然后我们按照情况四的方式进行调整即可。</p>
<p><img src="https://img-blog.csdnimg.cn/20200624160013634.jpg#pic_center" alt="情况五的第一次调整"></p>
<p>以上是本文的内容，红黑树的删除操作将在下一篇文章中进行介绍。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机-垃圾收集算法</title>
    <url>/2020/05/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>今天讨论的话题是垃圾收集算法，主要介绍一下标记-清除、标记-整理和标记-复制算法，还会基于这些算法讲一下分代垃圾收集算法。</p>
<a id="more"></a>

<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>首先讲一下标记-清除算法，这是最早出现也是最基础的一种算法。从名字就可以看出该算法分为两个过程：标记和清除。标记可以是标记存活对象，也可以是标记将要回收的对象，清除自然就是将要回收的对象的内存收回。我们通过一张图来了解标记-清除算法。</p>
<p><img src="https://img-blog.csdnimg.cn/20200531202410470.png?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="标记-清除算法"></p>
<p>上图中青色的部分是存活对象，棕色部分是可回收的对象，空白部分是未使用的内存。在一次垃圾回收以后，标记为可回收的对象均被清除。这种算法虽然简单，但是有一定局限性。由于可回收对象在内存中的分布不均匀，导致有可能出现当一个对象需要申请较大内存时，没有连续空间分配给对象。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p><img src="https://img-blog.csdnimg.cn/20200531203937766.png?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="标记-整理算法"></p>
<p>上图是标记-整理算法的图示，标记-整理算法与标记-清除算法不同的地方在于标记-整理算法是一种移动式的内存回收算法，它会将存活对象统一移动到一块内存并设置边界，回收边界外的所有对象。由于移动对象是一种极为负重的操作，因此在执行该算法时，其他所有的应用程序必须暂停，因此这种停顿被描述为“Stop The World”。</p>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p><img src="https://img-blog.csdnimg.cn/20200531205710366.png?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="标记-复制算法"></p>
<p>标记-复制算法将内存分为容量相等的两块，每次只使用其中一块区域，另一块是保留区域。每次垃圾回收，将存活着的对象复制到保留区域中。这种算法适合存活对象占少数的情况，如果存活对象占多数，将会进行大量的内存复制。IBM曾经做过一项调查显示，98%的对象都是“朝生夕灭”，但是这种算法每次保留50%的空间，实际上浪费了大量可用内存。</p>
<h2 id="分代垃圾收集算法"><a href="#分代垃圾收集算法" class="headerlink" title="分代垃圾收集算法"></a>分代垃圾收集算法</h2><p>以上三种垃圾收集算法各有优缺点，因此在真实的商用虚拟机设计中，用到了以上算法的思想并设计出了分代算法。在Java虚拟机中，设计者会把Java堆分为新生代和老年代两个区域。其中新生代还会被划分为Eden区和Survivor区，Survivor区还被分为From Survivor和To Survivor。Eden区、From Survivor和To Survivor的内存占比是8:1:1，下图展示了新生代内存的划分。</p>
<p><img src="https://img-blog.csdnimg.cn/20200531213248256.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="新生代内存区域"></p>
<p>新生代中垃圾回收采用的是标记-复制算法，算法流程如下：</p>
<ul>
<li><p>进行第一次垃圾收集时，垃圾收集器将Eden区的存活对象复制到From Survivor区，清空Eden区，存活对象计数加1</p>
</li>
<li><p>再次进行垃圾收集时，将Eden区和From Survivor区的存活对象复制到To Survivor区，清空Eden区和From Survivor区，存活对象计数加1，此时To Survivor变成了From Survivor，From Survivor变成了To Survivor</p>
</li>
<li><p>重复上一步</p>
</li>
</ul>
<p>需要注意的是，有一种极端情况：当Eden区和From Survivor区的存活对象复制到To Survivor区，但内存不够时，会触发内存担保机制，也就是将存活对象直接放入老年代。</p>
<p>新生代中的对象绝大多数都是朝生夕灭的，因此新生代区域是垃圾回收的主要区域。每一次的新生代的垃圾收集过程叫做Minor GC，如果经过一次Minor GC以后对象没有被回收，那么就会为这个对象的标记数加1。对于HotSpot虚拟机，当一个对象的标记数达到了15时，就会被移动到老年代。</p>
<p>但随着时间的推移，老年代的空间也会被用完，这时就会进行一次Full GC。Full GC发生时，新生代和老年代的垃圾都会被收集，因此对系统的影响比较大，应减少Full GC的发生次数。</p>
<p>老年代中的垃圾比较少，因此移动少量对象就可以完成垃圾清理，采用标记-整理算法可以做到回收老年代的垃圾。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>滴滴面试官：如何实现一个线程安全的单例模式</title>
    <url>/2020/10/09/%E6%BB%B4%E6%BB%B4%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式作为最常见的设计模式，有很多实现方式，今天介绍一下单例模式相关的内容。</p>
<a id="more"></a>

<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>从字面上理解，单例模式需要确保一个类只有一个对象。比如线程池、缓存、日志对象、打印机驱动对象、显卡驱动对象等，这些类的对象往往只需要一个实例就可以。如果一个类的对象需要被频繁创建，那么也会需要频繁GC，单例模式就可以解决这样的问题。</p>
<h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h2><p>单例模式的实现方式非常多，但总体上可以分为两类：饿汉式和懒汉式。饿汉式是在类加载过程中就创建对象的方式，而懒汉式是需要使用时才会去创建对象的方式，这两种方式各有特点。饿汉式存在的问题是如果要创建的对象占用的空间非常大，且使用频率非常低，那么这种方式是非常不划算的。而懒汉式有可能会遇到并发问题，这就要求我们需要考虑对创建对象的过程进行加锁。不管是饿汉式还是懒汉式，创建的对象一般都得使用static关键字进行修饰。</p>
<h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的饿汉式单例在类加载时创建了一个对象，然后创建了一个private修饰的构造方法防止通过构造方法创建对象。</p>
<h3 id="懒汉式单例（非线程安全版）"><a href="#懒汉式单例（非线程安全版）" class="headerlink" title="懒汉式单例（非线程安全版）"></a>懒汉式单例（非线程安全版）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种单例方式的创建我们可以很容易看出当需要使用这个对象时才会去创建，满足懒汉式的要求。但是这种创建单例的方式是有缺陷的，当多个线程同时获取对象，在判断对象是否为空的地方，如果两个线程同时到达，那么就会同时进入这个条件中，创建多个对象。下面提出一些线程安全的懒汉式单例。</p>
<h3 id="懒汉式单例（synchronized修饰的线程安全版）"><a href="#懒汉式单例（synchronized修饰的线程安全版）" class="headerlink" title="懒汉式单例（synchronized修饰的线程安全版）"></a>懒汉式单例（synchronized修饰的线程安全版）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于上面的非线程安全版本，我们在<code>getInstance()</code>方法上加上了synchronized锁，就变成了线程安全的版本。但是这种直接在方法上加锁的方式其实对并发的效率影响是很大的，尽管在JDK6中对synchronized做了很大优化，但是仍然不能满足我们对高并发的要求，下面介绍一下更加高效的双重校验锁版。</p>
<h3 id="懒汉式单例（双重校验锁版）"><a href="#懒汉式单例（双重校验锁版）" class="headerlink" title="懒汉式单例（双重校验锁版）"></a>懒汉式单例（双重校验锁版）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们又基于前面的非线程安全的版本实现了这个双重校验锁版的懒汉式单例，如果多个线程同时在外层判断对象为空时，开始抢占锁资源，抢到的线程创建对象，其他线程就不再需要创建线程了。这种方式的优点在于只有第一次抢夺资源的时候需要进行同步，后续的并发都会判断对象不为空，直接返回对象。</p>
<h3 id="懒汉式单例（静态内部类版）"><a href="#懒汉式单例（静态内部类版）" class="headerlink" title="懒汉式单例（静态内部类版）"></a>懒汉式单例（静态内部类版）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态内部类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHandler</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHandler.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方式依然是懒汉式单例，只不过利用静态内部类实现，同样也是线程安全的。</p>
<h3 id="饿汉式单例（枚举版）"><a href="#饿汉式单例（枚举版）" class="headerlink" title="饿汉式单例（枚举版）"></a>饿汉式单例（枚举版）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.singletonFactory.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">		singletonFactory;</span><br><span class="line">		<span class="keyword">private</span> EnumSingleton instance;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;	<span class="comment">//枚举类的构造方法在类加载时被实例化</span></span><br><span class="line">			instance = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> instance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是利用枚举创建单例对象的方法，利用枚举类加载时会实例化构造方法的特点进行单例模式的实现，是一种比较推荐使用的方法。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机-运行时数据区</title>
    <url>/2020/05/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<p>在Java虚拟机的概念中，运行时数据区又被称为Java内存区域。主要由线程私有的程序计数器、虚拟机栈和本地方法栈以及线程共享的堆和方法区组成。<br><img src="https://img-blog.csdnimg.cn/20200521144716505.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="Java虚拟机运行时数据区"></p>
<a id="more"></a>

<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器在Java内存中占据的空间比较小，是当前线程正在执行的字节码的行号指示器。字节码指令执行的过程中，分支、循环、跳转、异常处理、线程恢复等都需要通过程序计数器来完成。<br>在某一个时刻，一个内核只会执行一个线程中的指令，因此需要程序计数器来确保多线程切换后回复到某一线程能够继续之前的指令向后执行。因此，这也就决定了程序计数器必须是线程私有的。<br>当线程执行的是Java方法时，程序计数器保存当前正在执行的指令的地址，而当线程执行的是native方法时，程序计数器的值为<code>undefined</code>。<br>另外值得一提的是，程序计数器是运行时数据区中唯一不会出现<code>OutOfMemoryError</code>的。</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>当一个线程执行到某一个方法时，对应的是Java虚拟机创建一个栈帧，并将该栈帧压入虚拟机栈的过程。相对应的，方法结束则意味着虚拟机栈弹出该栈帧。<br><img src="https://img-blog.csdnimg.cn/20200521161137845.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="栈帧结构"><br>显而易见的是，局部变量表，存储的是方法中的局部变量。当局部变量是基本数据类型时，直接存储该变量的值，如果是引用数据类型，则存储对象引用。局部变量表在栈帧中分配的空间在编译阶段就已经确认，因此不会在方法运行期间改变大小。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>虚拟机栈和本地方法栈的原理十分相似，区别在于虚拟机栈执行的是Java方法，而本地方法栈执行的是Native方法。<br>由于JVM规范没有强制规定本地方法栈的实现，HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>对于C语言而言，堆是程序员可以直接管理的区域。程序员通过<code>malloc</code>和<code>free</code>方法申请和释放内存。<br>对于Java而言，堆存储着对象及对象数组。因此，也是垃圾回收器主要管理的区域。<br>根据JVM的规范，Java堆可以存储在物理不连续的区域，但逻辑上是连续的。对于大对象（如数组对象），很多虚拟机直接将它们存储在物理上连续的内存区域。另外，堆是所有线程共享的区域，因此JVM中只有一个堆。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和堆一样，都是线程共享的区域。方法区存放了类的信息（类名、字段信息、方法信息）、静态变量、常量以及编译后的代码缓存等数据。<br>很多人将方法区和“永久代”混为一谈，原因是HotSpot把垃圾收集器的设计扩展到了方法区，从而省去为方法区专门编写内存管理代码的工作。<br>运行时常量池是方法区的一部分，用于存放常量池表，常量池表中存放了编译期生成的各种符号字面量和符号引用。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/dolphin0520/p/3613043.html" target="_blank" rel="noopener">JVM的内存区域划分</a><br>深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载机制</title>
    <url>/2020/07/16/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>之前我们了解过class文件的存储格式，本文将介绍虚拟机如何加载class文件。</p>
<a id="more"></a>

<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://img-blog.csdnimg.cn/20200718102109679.png#pic_center" alt=""></p>
<p>一般来说，类的生命周期被划分为加载、验证、准备、解析、初始化、使用和卸载几个阶段，其中验证、准备和解析被统称为连接阶段。解析的过程顺序不确定，可能在初始化开始之后才开始，这常常出现在Java的晚绑定（动态绑定）中。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”和“类加载”听起来十分相似，但是加载只是类加载的一个阶段。加载阶段的三个任务：</p>
<ul>
<li>通过类的全限定名获取类的二进制字节流。</li>
<li>将二进制字节流转化成运行时数据结构。</li>
<li>在内存中生成这个类的<code>java.lang.Class</code>对象，作为方法区数据结构的访问入口。</li>
</ul>
<p>对于第一个任务，Java虚拟机规范并没有明确要求从字节码文件中获取二进制字节流，因此一般可以从以下途径获取：</p>
<ul>
<li>从压缩包获取，包括zip、jar、war格式等</li>
<li>从网络中获取，如web applet</li>
<li>运行时计算生成，较多的使用场景是动态代理技术</li>
<li>从数据库中获取</li>
<li>从加密文件中获取</li>
<li>……</li>
</ul>
<p>非数组类型的加载阶段是程序员可控制性最强的阶段，程序员可以通过自定义类加载器来控制字节流的获取方式。<br>数组类型本身并不是通过类加载器进行创建，而是通过JVM在内存中直接动态创建。但数组类的元素类型（去掉所有数组维度的类型）最终还是要靠类加载器加载，数组类的创建过程遵循下列规则：</p>
<ul>
<li>如果数组的组件类型（去掉一个维度的类型，区别于元素类型）是引用类型，就递归加载这个组件类型，数组会被标识在加载该组件类型的类加载器的类名称空间上。</li>
<li>如果数组的组件类型不是引用类型，JVM会将数组标记为与引导类加载器关联。</li>
<li>数组类的可访问性和组件类型的可访问性一致，如果组件类型不是引用类型，那么它的数组类的可访问性默认是public，所有的类和接口都可以访问。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证阶段保证class文件的字节流符合Java虚拟机规范，不会损害Java虚拟机的安全。验证阶段主要包括四个验证动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>文件格式验证是要验证字节流是否符合class文件格式规范，可以验证的地方主要包括：</p>
<ul>
<li>开头是否是魔数0xCAFEBABE</li>
<li>主次版本号能否被Java虚拟机接受</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
<li>class文件本身及各个部分是否有被删除或附加的其他信息</li>
<li>……</li>
</ul>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>主要包括以下验证点：</p>
<ul>
<li>这个类是否有父类（除了Object类以外的所有类都有父类）</li>
<li>这个类的父类是否继承了final修饰的类</li>
<li>如果这个类不是抽象类，是否实现了父类或接口要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾</li>
<li>……</li>
</ul>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>前面的元数据验证主要是用于数据类型校验，字节码校验是进行类的方法体校验，包括以下内容：</p>
<ul>
<li>任意时刻操作数栈的数据类型和指令代码序列都能配合工作，不会出现类似于“在操作数栈中放了一个int类型的数据，使用时按照long类型来载入本地变量表”的情况。</li>
<li>任何指令都不会跳转到方法体外的字节码指令上。</li>
<li>保证数据类型转换的合法性，子类对象可以赋值给父类数据类型，但反过来则不行，更不能将对象赋值给一个毫不相关的数据类型。</li>
<li>……</li>
</ul>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>符号引用验证主要是看该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。主要验证下列内容：</p>
<ul>
<li>符号引用中能否通过全限定名找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的字段和方法。</li>
<li>符号引用中的类、字段和方法的可访问性是否可以被当前类访问。</li>
<li>……</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>这个阶段是为静态变量分配内存并设置初始值的阶段，一般来说是应该在方法区上进行操作的，在JDK7之前，HotSpot使用永久代来实现方法区，但JDK8开始，永久代被移除，静态变量就和class对象一起被存放在了堆空间中。因此，静态变量是在逻辑上的方法区。<br>准备阶段的初始值并不是代码中赋予的值，而是“赋零值”的过程，一起看一下下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>尽管代码里面写的是给value赋1，但准备阶段应该是将0赋给value，真正将1赋给value的阶段应该是后面的初始化的阶段。下面列出了各种数据类型的零值。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">零值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short)0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘\u0000’</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte)0</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">null</td>
</tr>
</tbody></table>
<p>然而并不是所有情况都是赋零值的过程，当静态变量被final修饰时，例如下面这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这种情况下，value在编译阶段就已经生成了ConstantValue属性，所以在准备阶段就会把1赋给value。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段就是将常量池中的符号引用转换为直接引用的过程。前面提到了符号引用相关的内容，这里简要说明一下符号引用和直接引用的概念。</p>
<ul>
<li><p><strong>符号引用</strong>：符号引用是一组用符号来描述所引用的目标，这些符号可以无歧义地定位到目标。在前面讲类文件结构时就提到过符号引用如CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info等。</p>
</li>
<li><p><strong>直接引用</strong>：直接引用是可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载过程的最后一个阶段，前面的准备阶段我们说这是一个给静态变量赋零值的阶段，而到了初始化阶段就是真正给Java代码中的静态变量赋初始值的时候了。在初始化阶段，javac编译器会生成一个<code>&lt;clinit&gt;()</code>方法，用来给静态变量和静态语句块赋值。<code>&lt;clinit&gt;()</code>必须保证在多线程场景下被正确加锁同步，所以多个线程去执行<code>&lt;clinit&gt;()</code>方法时可能会遇到耗时操作导致阻塞。下面的代码进行了这种情况的演示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLoopClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">		<span class="keyword">static</span> &#123;</span><br><span class="line">			<span class="comment">//这里不加if语句会无法编译</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread() + <span class="string">" init DeadLoopClass"</span>);</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(Thread.currentThread() + <span class="string">" start"</span>);</span><br><span class="line">				DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">				System.out.println(Thread.currentThread() + <span class="string">" run over"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果如下，一个线程卡死了，另一个线程一直阻塞：</p>
<blockquote>
<p>Thread[Thread-0,5,main] start<br>Thread[Thread-1,5,main] start<br>Thread[Thread-0,5,main] init DeadLoopClass</p>
</blockquote>
<p>接下来看一下初始化的几种情况：</p>
<p>1.遇到new、getstatic、putstatic或invokestatic时触发初始化：</p>
<ul>
<li>当执行new指令时会初始化一个类，即创建一个类的实例对象。</li>
<li>当执行getstatic指令时会初始化一个类，即访问类的静态变量。</li>
<li>当执行putstatic指令时会初始化一个类，即给静态变量赋值。</li>
<li>当执行invokestatic指令时会初始化一个类，即调用类的静态方法。</li>
</ul>
<p>2.使用<code>java.lang.reflect</code>方法对类型进行反射调用的时候，如果类型没有初始化则先进行初始化。<br>3.当子类的父类没有初始化，先触发父类的初始化。<br>4.虚拟机启动时，需要指定一个要执行的主类（包含main()方法的类），虚拟机会先初始化这个类。<br>5.当使用JDK7加入的动态语言支持，如果<code>java.lang.invoke.MethodHandle</code>实例最后解析的结果是REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，且方法句柄对应的类没有被初始化，则先进行初始化。<br>6.当一个接口定义JDK8加入的默认方法（被default修饰的接口方法），当接口的实现类初始化，则接口要在实现类之前初始化。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>电路交换、报文交换与分组交换</title>
    <url>/2020/08/27/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E3%80%81%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<p>在计算机网络中有三种主要的数据交换方式，分别是电路交换、报文交换和分组交换。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/2020082910493216.png#pic_center" alt=""></p>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>电路交换需要建立一条专用的数据通信路径，这条路径上可能包含许多中间节点。这条通信路径在整个通信过程中将被独占，直到通信结束才会释放资源。电路交换适合实时性要求较高的大量数据传输的情况。</p>
<p>电路交换的优点主要包括以下几个方面：</p>
<ul>
<li>通信时延小。通信双方通过专用线路进行通信，数据可以直达。当数据传输量较大时，优点将十分显著。</li>
<li>线路独占，没有冲突。</li>
<li>实时性强。一旦通信线路建立，双方可以实时通信。</li>
</ul>
<p>电路交换的缺点主要包括以下几个方面：</p>
<ul>
<li>线路独占，利用率太低。</li>
<li>连接建立时间过长。</li>
</ul>
<h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><p>报文交换以报文作为数据传输单位，携带有源地址和目的地址等信息。</p>
<p>报文交换的优点主要包括以下几个方面：</p>
<ul>
<li>无需建立连接。</li>
<li>动态分配线路。</li>
<li>线路利用率高。</li>
</ul>
<p>报文交换的缺点主要包括以下几个方面：</p>
<ul>
<li>报文交换对报文的大小没有限制，需要网络节点有足够的缓存空间。</li>
<li>报文交换在节点处要经历存储、转发等操作，从而引起一定时延。</li>
</ul>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>分组交换是将大的数据块分割成小的分组，并添加源地址、目的地址和分组编号等信息。</p>
<p>分组交换的优点主要包括以下几个方面：</p>
<ul>
<li>无需建立连接。</li>
<li>线路利用率高。</li>
<li>相对报文交换，分组长度固定，缓冲区容易管理。</li>
<li>分组比报文小，因此传输时间更短。</li>
</ul>
<p>分组交换的缺点主要包括以下几个方面：</p>
<ul>
<li>仍然存在时延。</li>
<li>需要传输包括源地址、目的地址、分组编号等额外信息。</li>
<li>分组可能遇到失序、丢失、重复等问题。</li>
</ul>
<p>分组交换还可以进一步细分为数据报方式和虚电路方式。<br>数据报为网络层提供无连接服务，不同分组到达目的节点可能会乱序、重复或丢失。分组在交换节点时，可能会带来一定的时延。数据报方式适用于突发性通信，不适合长报文、会话式通信。<br>虚电路方式将数据报方式与电路交换结合，发挥两者优点。虚电路在源节点和目的节点建立一条逻辑链路，与电路交换不同的地方在于虚电路并不是独占链路资源的。虚电路方式避免了分组的乱序、重复和丢失等问题。</p>
<p>下面总结一下数据报服务和虚电路服务的区别：</p>
<ul>
<li>建立连接：数据报服务不要建立连接，虚电路服务需要建立连接。</li>
<li>目的地址：数据报服务的每个分组有完整的目的地址，虚电路服务只在建立连接时使用目的地址，当连接建立完成后使用长度较短的虚电路号。</li>
<li>路由选择：数据报服务的每个分组都是独立进行路由选择与转发的，虚电路服务属于同一条虚电路的分组按同一路由进行转发。</li>
<li>分组顺序：数据报服务不保证分组顺序，虚电路服务保证分组有序到达。</li>
<li>可靠性：数据报服务不保证可靠通信，由用户主机保证可靠性，虚电路可靠性由网络来保证。</li>
<li>对网络故障的适应性：数据报服务出故障的节点丢失分组，其他分组路径变化可正常传输，虚电路服务所有经过故障节点的虚电路都不能工作。</li>
<li>差错处理和流量控制：数据报服务由用户主机进行流量控制，不保证数据可靠性，虚电路服务可由分组交换网或用户主机负责差错处理及流量控制。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>简单理解线段树</title>
    <url>/2020/07/12/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>线段树是二叉树的一种，常常被用于求区间和与区间最大值等操作。</p>
<a id="more"></a>

<h2 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h2><p>想象一下这种场景，一个数组现在需要进行两种操作：对某区间内数字进行求和与更新数组中的某个元素。对于更新元素操作很容易看出它的时间复杂度是$O(1)$，区间求和的时间复杂度是$O(n)$。</p>
<p><img src="https://img-blog.csdnimg.cn/20200712161116106.png#pic_center" alt=""></p>
<p>通过下面这种方法可以降低区间元素求和的时间复杂度：设置另一个数组<code>sum_table</code>，这个数组每个位置的值存储<code>table</code>数组中当前位置及之前的所有元素之和。这样，我们可以把区间元素求和的时间复杂度降为$O(1)$，以区间[1,4]为例，计算方法为<code>sum_table[4]-sum_table[0]</code>。但这时更改元素的时间复杂度又上升了，修改了下标为8的元素，那么在<code>sum_table</code>中需要把下标为8及之后的元素都要进行修改。</p>
<p><img src="https://img-blog.csdnimg.cn/20200712162256110.png#pic_center" alt=""></p>
<p>如果我们想把这两个操作的时间复杂度平均一下就需要用到今天介绍的线段树了。简单起见，我们用个短一点的数组来进行表示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200714160113438.png#pic_center" alt=""></p>
<p>上面这幅图，根节点是整个[0-5]范围内的区间元素之和，左孩子是前一半的数组和，右孩子是后一半的数组和，以此类推，叶子节点是每一个元素的值。这样不管是更新元素值还是求区间元素和都会是$O(logn)$的复杂度。</p>
<p>为了方便后面进行代码表示，我们把上面那幅图稍微修改一下。给每个结点从上至下、从左至右开始编号，并且补齐空缺的结点使其成为一棵完全二叉树，根据编号将这些结点填入数组<code>tree</code>中。</p>
<p><img src="https://img-blog.csdnimg.cn/2020071416011418.png#pic_center" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先看一下构建线段树的代码实现。很明显这是一个递归调用的过程，由于每次将<code>arr</code>一分为二，因此递归出口就比较明显了，就是当区间的左边界与右边界相同时，也就是$start == end$时，进行<code>tree</code>数组填充。递归填充结点的左子树和右子树然后将左右孩子的值加起来得到当前结点的值。<code>left_node</code>和<code>right_node</code>的值是根据完全二叉树的性质得到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">		tree[node] = arr[start];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> left_node = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> right_node = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		buildTree(arr, tree, left_node, start, mid);</span><br><span class="line">		buildTree(arr, tree, right_node, mid + <span class="number">1</span>, end);</span><br><span class="line">		tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是更新结点的代码，同样也是递归调用，递归出口和之前一样，还是区间边界相等时递归结束。二分查找判断需要更新哪一边的元素，找到更新结点并更新完成后逐级向上更新上层的结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> idx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">		arr[idx] = val;</span><br><span class="line">		tree[node] = val;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> left_node = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> right_node = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (idx &gt;= start &amp;&amp; idx &lt;= mid) &#123;</span><br><span class="line">			updateTree(arr, tree, left_node, start, mid, idx, val);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			updateTree(arr, tree, right_node, mid + <span class="number">1</span>, end, idx, val);</span><br><span class="line">		&#125;</span><br><span class="line">		tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是区间求和部分的代码，依然是递归实现的代码。我们还是从根节点出发，求出左边的和<code>sum_left</code>与右边的和<code>sum_right</code>，然后加起来就是区间和了。当然左边或右边也许并不在区间内，这就需要考虑递归出口了。首先我们需要考虑待求和区间与当前递归区间不重合的情况，这时返回0，结束当前递归。接着是当前区间是待求和区间的子区间的情况，直接返回当前区间的和，也就是当前结点的值。第三种情况其实可以算是第二种情况的特殊情形，也就是遇到结点是待求和区间中的元素，同样返回结点值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (end &lt; L || start &gt; R) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (L &lt;= start &amp;&amp; end &lt;= R) &#123;</span><br><span class="line">		<span class="keyword">return</span> tree[node];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">		<span class="keyword">return</span> tree[node];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> left_node = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> right_node = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> sum_left = queryTree(arr, tree, left_node, start, mid, L, R);</span><br><span class="line">		<span class="keyword">int</span> sum_right = queryTree(arr, tree, right_node, mid + <span class="number">1</span>, end, L, R);</span><br><span class="line">		<span class="keyword">return</span> sum_left + sum_right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是测试代码的部分。将数组<code>arr</code>构建成一棵线段树，需要注意的部分是<code>tree_size</code>也就是<code>tree</code>长度的计算，首先需要求出线段树的高度$h$为$\lceil log_2{size} \rceil+1$，然后根据完全二叉树的性质得到<code>tree_size</code>为$2^h-1$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> tree_size = (<span class="keyword">int</span>) (Math.pow(<span class="number">2</span>, Math.ceil(Math.log(size) / Math.log(<span class="number">2</span>)) + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span>[] tree = <span class="keyword">new</span> <span class="keyword">int</span>[tree_size];</span><br><span class="line">	SegmentTree sTree = <span class="keyword">new</span> SegmentTree();</span><br><span class="line">	sTree.buildTree(arr, tree, <span class="number">0</span>, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree_size; ++i) &#123;</span><br><span class="line">		System.out.printf(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">	</span><br><span class="line">	sTree.updateTree(arr, tree, <span class="number">0</span>, <span class="number">0</span>, size - <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree_size; ++i) &#123;</span><br><span class="line">		System.out.printf(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> s = sTree.queryTree(arr, tree, <span class="number">0</span>, <span class="number">0</span>, size - <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">	System.out.println(<span class="string">"s = "</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是线段树的完整Java代码实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">			tree[node] = arr[start];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">int</span> left_node = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> right_node = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">			</span><br><span class="line">			buildTree(arr, tree, left_node, start, mid);</span><br><span class="line">			buildTree(arr, tree, right_node, mid + <span class="number">1</span>, end);</span><br><span class="line">			tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> idx, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">			arr[idx] = val;</span><br><span class="line">			tree[node] = val;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">int</span> left_node = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> right_node = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (idx &gt;= start &amp;&amp; idx &lt;= mid) &#123;</span><br><span class="line">				updateTree(arr, tree, left_node, start, mid, idx, val);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				updateTree(arr, tree, right_node, mid + <span class="number">1</span>, end, idx, val);</span><br><span class="line">			&#125;</span><br><span class="line">			tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (end &lt; L || start &gt; R) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (L &lt;= start &amp;&amp; end &lt;= R) &#123;</span><br><span class="line">			<span class="keyword">return</span> tree[node];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">			<span class="keyword">return</span> tree[node];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">int</span> left_node = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> right_node = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">int</span> sum_left = queryTree(arr, tree, left_node, start, mid, L, R);</span><br><span class="line">			<span class="keyword">int</span> sum_right = queryTree(arr, tree, right_node, mid + <span class="number">1</span>, end, L, R);</span><br><span class="line">			<span class="keyword">return</span> sum_left + sum_right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">int</span> tree_size = (<span class="keyword">int</span>) (Math.pow(<span class="number">2</span>, Math.ceil(Math.log(size) / Math.log(<span class="number">2</span>)) + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span>[] tree = <span class="keyword">new</span> <span class="keyword">int</span>[tree_size];</span><br><span class="line">		SegmentTree sTree = <span class="keyword">new</span> SegmentTree();</span><br><span class="line">		sTree.buildTree(arr, tree, <span class="number">0</span>, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree_size; ++i) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		sTree.updateTree(arr, tree, <span class="number">0</span>, <span class="number">0</span>, size - <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree_size; ++i) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> s = sTree.queryTree(arr, tree, <span class="number">0</span>, <span class="number">0</span>, size - <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">"s = "</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了本文中用于求区间和的操作，线段树还可以求区间最大值，只需要将结点存放的值由子树和改成子树最大值即可。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>美团面试官：说说MySQL的索引</title>
    <url>/2020/10/04/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4MySQL%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>从本文开始，选取牛客网上大厂的面试题，整理出相关内容的知识点。</p>
<a id="more"></a>

<h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>小学时我们经常用到的字典里有音节索引和部首目录，当我们查字典时，常常用音节索引和部首目录帮助我们提高查找汉字的速度。MySQL中同样也有索引，当MySQL需要查找数据时，索引也会提高检索数据的速度。</p>
<p><img src="https://img-blog.csdnimg.cn/20201004112603676.jpg#pic_center" alt=""></p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>创建索引的一个最重要的原因是索引能够快速检索数据，极大减少了数据检索量。创建唯一索引能够保证数据表中数据的唯一性。当我们需要进行表连接操作时，索引加速表连接操作。进行分组或排序查询时，也能够加速查询。</p>
<p>以上都是索引的优点，绝大部分优点都是帮助MySQL变得更快。那索引有什么缺点呢？首先索引作为数据库的一部分，本身就需要占用一定的物理空间。另外，当我们需要对数据表进行频繁插入、删除操作时，MySQL也需要动态维护索引。</p>
<h2 id="有哪些常见的索引"><a href="#有哪些常见的索引" class="headerlink" title="有哪些常见的索引"></a>有哪些常见的索引</h2><p><strong>主键索引</strong>：一张表只有一个主键索引，不允许重复，不允许为null。<br><strong>唯一索引</strong>：一张表可以有多个唯一索引，不允许重复，允许为null。<br><strong>普通索引</strong>：基本的索引类型，允许数据重复，允许为null。<br><strong>前缀索引</strong>：前缀索引用于字符串类型，取文本的前几个字符创建索引。<br><strong>全文索引</strong>：一般用于大文本数据检索，是当前搜索引擎中使用的关键技术。</p>
<p>以上索引中，除了主键索引外，其他四种索引统称为二级索引。</p>
<p>对于InnoDB引擎，一定存在主键索引。大家可能会奇怪，明明我在创建表的时候没有设置主键为什么我也能够创建成功？主要原因是InnoDB对于没有手动创建主键的表会选择一个唯一非空列作为主键，如果仍然不存在就设置一个隐藏的列作为主键。</p>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>MySQL中最多的两种索引是哈希索引和B树索引。哈希索引底层使用哈希表，在绝大部分情况下，查询单条记录使用哈希索引性能最快。B树索引是InnoDB存储引擎默认的索引实现方式，但实际底层使用的是B+树（MySQL打印表索引显示BTREE而不是B+TREE），在大部分场景下建议使用B树索引。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引的实现主要通过将数据库中的字段数据转换成为定长的hash值并与指向数据的指针一并放入hash表。如果发生hash碰撞，则在对应的hash键上使用拉链法进行存储。下图模拟了哈希索引的基本思路。</p>
<p><img src="https://img-blog.csdnimg.cn/20201004161204867.png#pic_center" alt=""></p>
<h3 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h3><p><img src="https://img-blog.csdnimg.cn/20201004165407101.jpg#pic_center" alt=""></p>
<p>上图是一棵B+树，每一个结点是一个磁盘块，结点中的深蓝色部分表示数据项、黄色部分表示指针。磁盘块1上有17和35两个数据项，还有P1、P2和P3三个指针。P1指向比17小的磁盘块，P2指向比17大比35小的磁盘块，P3指向比35大的磁盘块。磁盘块5~磁盘块11表示叶子节点。当我们要查找数据项10时，首先将磁盘块1加载到内存中，使用二分查找确定10比17小，接着加载指针P1指向的磁盘块2到内存中，同样使用二分查找找到磁盘2的P2指针指向的磁盘块6，将其加载到内存中，同时用二分查找找到数据项10。本次查询一共进行了三次IO操作，如果没有索引，每个数据项进行一次IO，那么将极大增加数据检索的成本。</p>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>最左前缀原则是指当建立了联合索引如(a,b,c)时，可以根据a/(a AND b)/(a AND b AND c)三种条件使索引进行检索，一般需要将最频繁使用的列放到最左边。当使用<code>=</code>或<code>in</code>时可以乱序a、b、c三个条件，MySQL会自动优化索引可识别的形式。<br>另外，当遇到范围查询（LIKE、BETWEEN、&gt;、&lt;）则会停止匹配。</p>
<blockquote>
<p>SELECT * FROM user WHERE a=1 AND b=1 AND c&gt;1 AND d=1</p>
</blockquote>
<p>上面的SQL语句建立了(a,b,c,d)的索引，只能匹配到(a AND b)，遇到<code>d&gt;1</code>直接停止使用索引匹配，不过如果建立(a,b,d,c)的索引就可以匹配到d。</p>
<h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><p><img src="https://img-blog.csdnimg.cn/20201006143938577.png#pic_center" alt=""></p>
<p>首先解释一下聚集索引又被称为聚簇索引，是指将数据和索引放到一起的索引，当找到索引也就找到了数据。在InnoDB引擎中，B+树的非叶子结点存放的都是索引，而叶子结点存放的是索引和数据。非聚集索引又被称为非聚簇索引，是将数据和索引分开存储。InnoDB的主键索引是聚集索引，MyISAM的主键索引和二级索引都是非聚集索引。InnoDB的非主键索引的叶子结点上存放着行的主键值，当找到索引数据时可能需要根据主键值回表，也就是说当查到主键后会根据主键值回到表中查询。</p>
<h3 id="聚集索引的优缺点"><a href="#聚集索引的优缺点" class="headerlink" title="聚集索引的优缺点"></a>聚集索引的优缺点</h3><p>聚集索引查询往往非常快，因为当定位到索引时，也就直接定位到了数据。但是聚集索引非常依赖有序数据，当插入或查找类似于UUID这种复杂的字符串时，往往速度很慢。还有就是聚集索引的更新代价很大，一般来说如果更新索引列数据，那么索引结构也要修改，所以主键是不建议被修改的。</p>
<h3 id="非聚集索引的优缺点"><a href="#非聚集索引的优缺点" class="headerlink" title="非聚集索引的优缺点"></a>非聚集索引的优缺点</h3><p>非聚集索引的更新代价较小，因为叶子节点不存放数据。但非聚集索引也非常依赖有序的数据，另外非聚集索引可能需要回表。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>当索引中包含要查找的字段的值，那么我们称其为覆盖索引。我们用一个例子解释一下什么是覆盖索引。</p>
<blockquote>
<p>SELECT age FROM user WHERE age&lt;40</p>
</blockquote>
<p>我们创建了age的索引，当我们检索到索引的时候，待查询的数据也已经存在，此时我们就不需要回表。当我们在写SQL时，要尽量只查询必要的字段，增加覆盖索引的概率。</p>
<h2 id="创建索引注意事项"><a href="#创建索引注意事项" class="headerlink" title="创建索引注意事项"></a>创建索引注意事项</h2><ul>
<li>被频繁检索的字段可以考虑创建索引。</li>
<li>频繁修改的字段不适合创建索引。</li>
<li>被索引的字段不适合为null。</li>
<li>where子句中的列可以考虑创建索引。</li>
<li>对于经常进行表连接和排序的字段可以创建索引。</li>
<li>避免创建冗余索引，例如(a,b)和(a)就是冗余索引，能够命中后者的索引也可以命中前者的索引。</li>
<li>一般来说没有太大区分度的列（例如性别只有男和女）就不要使用索引了。</li>
<li>尽量扩展索引而不是创建索引，例如表中已有a的索引，要加上(a,b)的索引，可以考虑扩展原来a的索引。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络层（更新中）</title>
    <url>/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p>网络层位于TCP/IP结构中的第三层，也是计算机网络中的重点和难点之一。</p>
<a id="more"></a>

<h2 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h2><ul>
<li><strong>异构网络互联</strong>。异构网络互联是指将多个计算机网络通过中继系统连接起来，这些网络在物理上是异构的。物理层和数据链路层的设备只是进行网络的扩大，而不是网络互联。</li>
<li><strong>路由与转发</strong>。路由与转发实际上是两个部分：路由选择、分组转发。路由选择是根据特定路由选择算法从相邻路由器获得网络拓扑变化从而动态更新路由。路由转发是选择合适的端口将分组转发出去。</li>
<li><strong>拥塞控制</strong>。随着网络负载的增大，如果吞吐量明显小于正常的吞吐量，那么网络可能就进入了拥塞状态。与流量控制不同的是，拥塞控制是一个全局性问题，涉及到网络中的所有主机、路由器等设备，而流量控制只需要控制发送端和接收端的通信量，保证接收端来得及接收发送端发来的数据。拥塞控制的方法主要有两种：开环控制和闭环控制。开环控制是一种静态方法，在系统启动之前决定何时接收新流量、丢弃分组，丢弃哪些分组等问题。而闭环控制是一种动态方法，无需提前考虑拥塞因素，一旦发现网络发生拥塞，将拥塞信息发送到合适的地方，动态调整网络系统。</li>
</ul>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p>在介绍路由算法之前，需要先介绍一下<strong>静态路由</strong>和<strong>动态路由</strong>的概念。静态路由需要网络管理员手动配置路由信息，一旦链路状态或拓扑结构发生变化，网络管理员就要去修改路由表中的静态路由信息。动态路由是路由器之间相互交换路由表信息，通过一定算法优化得出的最优寻路方式。静态路由比较适合于拓扑变化不大的小型网络或需要保证安全性和稳定性的军事系统，而动态路由适合复杂的大型网络。常见的动态路由算法有距离向量路由算法和链路状态路由算法。</p>
<h3 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h3><p>距离向量路由算法中，节点之间定期向相邻节点发送路由表，路由表的内容包括每条路径的目的地和路径的距离。</p>
<blockquote>
<p>这里说的距离不是物理上说的距离，而是一个抽象概念，在RIP算法中将距离定义为“跳数”，也就是指从源端口到目的端口经过的路由器数量。</p>
</blockquote>
<p>距离向量路由算法的所有节点都在监听相邻节点的路由更新信息，并在以下两种情况下更新路由选择表信息：</p>
<p>1.被通知有一条新的路由，这个路由在当前节点的路由表中并不存在。<br>2.到达某一目的地有比当前使用路由更短距离的路由，就用较短路由代替当前路由。</p>
<h3 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h3><p>使用链路状态路由算法的网络中的节点会主动测试相邻节点的状态并在链路发生变化时将链路状态发送给网络中的<strong>全部节点</strong>。在这里每次链路状态更新时，节点都会利用迪杰斯特拉算法更新最短路径。链路状态路由算法具有以下三个特征：</p>
<p>1.使用泛洪法向本自治系统所有的路由器发送信息，即向相邻所有节点发送信息，每个相邻节点又向除刚刚发送信息的节点继续发送信息。<br>2.发送的信息是与路由器相连的所有路由器的链路状态。<br>3.当链路状态发生改变时，路由器才会向所有路由器发送信息。</p>
<p>与距离向量路由算法相比，链路状态路由算法不依赖中间节点的计算，并且节点通过广播的方式与所有节点交谈。</p>
<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p>随着网络规模的逐渐扩大，路由表中的信息越来越多，因此层次路由的概念被提了出来。层次路由是将互联网划分为多个自治系统，每个自治系统又包含很多局域网。一个自治系统内部使用内部网关协议（IGP），具体的协议有RIP和OSPF等。OSPF会将一个自治系统划分成若干个区域，路由器并不知道区域内的结构细节。</p>
<p>自治系统之间采用外部网关协议（EGP），用于不同自治系统的路由器交换路由信息，并选择最优路径，具体协议有BGP。</p>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-传输层</title>
    <url>/2020/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>计算机网络的传输层是整个计算机网络体系中的关键层次，向上层的应用层提供服务，它是面向通信部分的最高层，也是用户功能中的最低层。</p>
<a id="more"></a>

<h2 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><ul>
<li><p>提供应用进程间的通信。我们的计算机上运行着多个应用程序，而每个程序却能够准确与对应服务器进行通信，你知道这是为什么吗？我们需要引出一个概念：端口。<br>什么是端口？当我们上网时，可能有一部分网站在输入网址后跟上<code>:(数字)</code>，这里网址后的数字就是我们的端口号。常见的端口号有web服务器的80端口，ftp服务器的21和20端口，SMTP的25端口等。这些都是服务器端的端口，当我们的客户机和服务器进行连接时，会分配一个端口号，这就是识别进程的唯一标识。传输层通过端口提供端到端的逻辑通信，好像沿着水平方向传输数据，但事实上传输层之间没有水平方向上直接的物理连接。</p>
</li>
<li><p>复用和分用。复用是指不同应用进程可使用同一个传输层协议传输数据，分用则是指接收方的传输层在剥去报文首部以后可以将数据发送到对应的进程。</p>
</li>
<li><p>差错检测。</p>
</li>
<li><p>提供TCP和UDP两种协议。当采用TCP协议时，尽管下面的网络是不可靠的，它却能提供逻辑上的可靠信道。而当采用UDP时，逻辑信道仍是不可靠的，只是尽力保证交付数据。</p>
</li>
</ul>
<h2 id="面向连接服务和无连接服务"><a href="#面向连接服务和无连接服务" class="headerlink" title="面向连接服务和无连接服务"></a>面向连接服务和无连接服务</h2><p>面向连接服务是指当通信双方在通信前首先建立连接，通信过程中连接一直保持，通信完毕后会释放连接。TCP就是面向连接的传输协议，向上提供可靠的逻辑信道。<br>无连接服务是指通信双方在通信时无需建立连接，发送方直接将信息发送到网络中，只是尽力交付信息。UDP是无连接的传输协议，向上提供的则是不可靠的逻辑信道。</p>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP协议的特点"><a href="#UDP协议的特点" class="headerlink" title="UDP协议的特点"></a>UDP协议的特点</h3><ul>
<li><p>无需建立连接。与TCP不同的是，UDP不需要提前建立连接，这意味着UDP协议比TCP协议更快，因此对于一些对速度要求较高的应用（如DNS，网络音视频通话等）常常选用UDP协议。</p>
</li>
<li><p>传输不可靠。省去了建立连接的过程，UDP直接将数据发送到网络，无法保证传输的可靠性。</p>
</li>
<li><p>UDP是面向报文的。应用程序交付的报文，UDP既不合并，也不拆分，直接添加首部以后交给网络层添加首部。</p>
</li>
<li><p>分组首部开销小。UDP首部只有8B，而TCP有20B的首部开销。</p>
</li>
<li><p>应用层可以控制发送时间和发送的数据。UDP没有拥塞控制，所以网络中的拥塞不影响主机发送效率。</p>
</li>
</ul>
<h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h3><p>UDP数据报主要由用户数据和UDP首部组成，其中UDP首部由源端口、目的端口、UDP长度和UDP校验和组成。其中UDP长度的最小值为8，表示只有UDP首部而没有数据部分。</p>
<p><img src="https://img-blog.csdnimg.cn/20200522165926646.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="UDP数据包格式"></p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h3><ul>
<li><p>TCP是面向连接的传输层协议。</p>
</li>
<li><p>TCP提供可靠交付服务，能保证数据有序、无差错、不重复且无丢失。</p>
</li>
<li><p>允许全双工通信，通信双方能够同时发送和接受数据。因此通信双方都有发送缓存和接收缓存。</p>
</li>
<li><p>TCP协议面向字节流。TCP协议将应用层传递下来的数据视为一串无结构的字节流。</p>
</li>
</ul>
<h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h3><p><img src="https://img-blog.csdnimg.cn/2020052318234629.png?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="TCP报文段格式"></p>
<ul>
<li><p>源端口和目的端口各占2B，前面UDP数据报也有。</p>
</li>
<li><p>序号字段占4B，是该报文段第一个字节的序号，比如当前报文段的序号是101，报文段的长度是100B，说明当前报文段的最后一个字节的序号是200，则下一个报文段序号是201。</p>
</li>
<li><p>确认号字段占4B，是指期望收到的下一个报文段的第一个字节的序号。例如B收到A发送的报文段，这个报文段的序号是101，报文段长度是100B，B期望收到的下一个报文段是第一个字节序号是201，所以确认号就是201。</p>
</li>
<li><p>数据偏移占4bit，用于表示首部长度。数据偏移的单位是32位（4B），因此当数据偏移的值是15时，达到首部长度最大值60B。</p>
</li>
<li><p>保留字段占6bit，用作保留今后使用，全为0，可忽略不计。</p>
</li>
<li><p>紧急位URG占1bit，当URG=1时表示有紧急数据传送，相当于提高了优先级。</p>
</li>
<li><p>确认位ACK占1bit，当ACK=1时表示确认号字段有效，若该值为0时表示确认号字段无效。TCP规定在连接建立以后所有报文段的ACK都要置为1。</p>
</li>
<li><p>推送位PSH占1bit，当PSH=1时表示尽快交付应用程序，而不需要等到缓存满了以后再向上交付。</p>
</li>
<li><p>复位位RST占1bit，当RST=1时表示TCP连接过程中出现严重错误（如主机崩溃等）需要释放当前连接，然后重新建立连接。</p>
</li>
<li><p>同步位SYN占1bit，当SYN=1时表示这是连接请求或连接接收报文。当SYN=1且ACK=0时，则表明是连接请求报文。若对方同意建立连接，则在响应报文中设置SYN=1和ACK=1。</p>
</li>
<li><p>终止位FIN占1bit，当FIN=1时表示传输完毕，准备释放连接。</p>
</li>
<li><p>窗口字段占2B，接收方的缓存空间有限，该字段用于指定发送方允许发送的数据的长度，单位为字节。举个例子，当确认号为701，窗口字段为1000，表示从701号算起，接收方还有1000B的缓存接收空间。</p>
</li>
<li><p>校验和占2B，和UDP一样用于数据校验。</p>
</li>
<li><p>紧急指针字段占2B，指出该报文段有多少字节的紧急数据，其中紧急数据在报文段数据的最前面。</p>
</li>
<li><p>选项字段长度可变，TCP最初只规定了一种选项，即最大报文段长度（MSS），MSS是TCP报文段中数据字段的最大长度。</p>
</li>
<li><p>填充字段是为了使首部长度是4B的整数倍而存在。</p>
</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手在面试中属于极其高频的面试点，几乎是问到计算机网络的知识就会问三次握手。</p>
<p><img src="https://img-blog.csdnimg.cn/20200524154116793.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="三次握手"></p>
<p>三次握手的第一步是客户端向服务器发起连接请求，这个请求中不携带数据。第一次握手的首部SYN设置为1，客户端还会随机分配一个起始序号seq=x。<br>第二步是当服务器收到客户端发送的报文段后，若同意建立连接，就向客户端返回一个确认报文段，并为该连接分配缓存和变量。确认报文段将SYN和ACK设置为1，设置确认号ack=x+1，服务器随机产生一个起始序号seq=y。这个确认报文段同样也不携带数据。<br>第三步是客户端收到了来自服务器的确认建立连接报文段后，向服务器发送确认信息，并为连接分配缓存和变量。此时的报文段ACK被设置为1，序号seq被设置为x+1，确认号ack被设置为y+1。该报文段可以携带数据，若不携带数据则不消耗序号。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>与三次握手建立连接相对的，四次挥手是TCP断开连接的方式。</p>
<p><img src="https://img-blog.csdnimg.cn/20200525145942799.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="四次挥手"></p>
<p>四次挥手第一步是客户机主动关闭连接，向服务器发送一个释放连接报文段，并停止发送数据。这个报文段的FIN终止位被置为1，并设置序号seq=u。此时客户机关闭了数据通路，但是由于TCP是全双工的，所以服务器仍然可以发送数据。<br>第二步是服务器接收到客户机发送的连接释放请求，向客户端发送确认报文段。将ACK设置为1，确认号ack=u+1，序号seq=v。此时客户机到服务器的连接释放了，但是服务器到客户端的数据通路仍然是连接的。<br>第三步是服务器已经没有需要传输的数据，则向客户机发送FIN=1的报文段释放连接。<br>第四步是客户机收到服务器的释放连接报文段后，向服务器发送确认报文段，报文段的ACK被置为1。此时还需要再等2MSL后，客户机才进入连接关闭状态。</p>
<h3 id="TCP可靠连接"><a href="#TCP可靠连接" class="headerlink" title="TCP可靠连接"></a>TCP可靠连接</h3><p>我们知道，TCP和UDP的不同点之一就是TCP是可靠连接而UDP是不可靠连接。下面就介绍一下TCP保证可靠连接的措施。<br>TCP确认机制是建立在报文段序号之上的，当接收方收到了发送方发来的0-2字节和6-8字节，而一直未收到3-5的字节，此时接收方向发送方返回的报文段中确认号设置为3，表示期待序号为3的报文段。重传有超时和冗余ACK两种实现机制，超时重传很容易理解，冗余ACK从字面上理解就是发送冗余的ACK。举个例子，A向B发送了序号为1、2、3、4、5、6的六个报文段，但B只收到了1、2、4、5、6号的报文段，此时B期望收到的报文段是3号，而4-6号报文段却先于3号送达，所以B向A发送3个ack=3的冗余ACK。根据TCP规定，当冗余ACK达到3个时，就视为那个报文段已经丢失，发送方A将重新发送3号报文。因为冗余ACK比起超时重传用时更短，因此又被称为快速重传。</p>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>什么是流量控制？为什么需要流量控制？我们知道，发送方发送分组和接收方接收分组的速率并不完全一致，很可能存在发送方发送分组过快导致丢包的现象。这时候就需要一种机制来实现制约发送方发送速率的情况，TCP流量控制就是解决这个问题的方法。<br>当发送方向接收方发送数据时，接收方会向发送方返回一个接收窗口值，这个接收窗口配合确认号ack可以控制发送方发送速率。以下是窗口机制实现流量控制实例。</p>
<p><img src="https://img-blog.csdnimg.cn/2020052618230555.png?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="可变窗口实现流量控制实例"></p>
<p>上图中主机A向主机B发送数据刚开始建立连接时，窗口大小是400，后来随着发送方发送数据的增加，窗口也在动态调整大小。值得一提的是，TCP窗口单位是字节不是报文段。</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>拥塞控制和流量控制不同，拥塞控制是指TCP通过控制数据传输速率防止因数据过多造成网络阻塞。TCP规定发送方不仅要维护一个拥塞窗口，这个拥塞窗口的大小是发送方根据网络拥塞情况进行判断从而确定的。所以发送方发送速率不仅取决于接收窗口的大小，也取决于拥塞窗口的大小，发送上限取这两个窗口的较小值。<br>TCP维护拥塞窗口的算法主要包括四个：慢开始、拥塞避免、快重传和快恢复。</p>
<ul>
<li><p>慢开始。慢开始的“慢”不是指拥塞窗口cwnd的发送速率慢，而是TCP在初始设置的拥塞窗口较小，慢慢增大进行网络拥塞试探。算法最初设置窗口大小cwnd=1，每次接收到一个确认报文段后，都会将窗口值加一。于是一次往返延迟时间（RTT）以后，接收方对那个报文进行确认，拥塞窗口cwnd=2。再经过一次RTT以后，接收方对两个报文进行确认，cwnd=4。以此类推，我们可以发现，拥塞窗口大小是呈指数增长的，这印证了前面说的慢开始的“慢”不是发送速率慢。当拥塞窗口超过了一个阈值ssthresh之后，开始使用拥塞避免算法。</p>
</li>
<li><p>拥塞避免。拥塞控制算法的思想是当慢开始使拥塞窗口大小达到阈值ssthresh时，每次经过一个RTT时，窗口大小增加1，而不是像慢开始一样，每次都是成倍增长。当出现一次拥塞时，将阈值ssthresh设置成为当前拥塞窗口cwnd的大小的一半（但阈值不能小于2）。然后拥塞窗口cwnd重新设置为1，重新进行慢开始算法。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200526230338111.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="TCP拥塞窗口cwnd在拥塞控制时的变化情况"></p>
<p>从上图可以看出当窗口cwnd达到24时，出现网络拥塞，阈值ssthresh被降为此时cwnd的一半即为24，并重新进入慢开始阶段。</p>
<ul>
<li><p>快重传。前面的TCP可靠传输中我们提到了冗余ACK可以保证TCP的可靠性，在这里的快重传中我们同样使用冗余ACK来完成丢包检测。一旦接收方收到了失序的报文，立马发送一个ACK给发送方。当发送方收到三个同样的ACK报文时，就可以认为发生了丢包，需要进行重传。</p>
</li>
<li><p>快恢复。快恢复的思想是一旦发送方接受到三个重复的ACK报文时，将阈值ssthresh设置为当前拥塞窗口cwnd的一半，然后跳过慢开始的步骤，直接将拥塞窗口的值设置为ssthresh，使拥塞窗口大小线性增加。</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>2020王道计算机网络<br>计算机网络（第7版）-谢希仁<br><a href="https://www.cnblogs.com/kubidemanong/p/9987810.html" target="_blank" rel="noopener">通俗易懂讲解TCP流量控制机制，了解一下</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈Java容器-ArrayList</title>
    <url>/2020/05/27/%E8%B0%88%E8%B0%88Java%E5%AE%B9%E5%99%A8-ArrayList/</url>
    <content><![CDATA[<p>ArrayList是面试中常见的Java容器，也算是Java中比较简单的容器，我们今天就来讲讲ArrayList的源码和常见的面试点。</p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ArrayList是一种底层基于数组实现的容器，并且能够实现随元素数量增加而进行动态扩容。与LinkedList相比，ArayList非常适合于查找元素，原因在于ArrayList底层实现原理是数组存储的内存在物理上是连续的，但增加和删除元素时，ArrayList比起LinkedList就比较慢了。此外，ArrayList是线程不安全的容器，要使用线程安全的集合容器，可以使用Vector。Vector实现线程安全的方式非常简单，直接在方法上加上了synchronized同步锁。ArrayList也可以通过<code>Collections.synchronizedList</code>将ArrayList包装一层同步锁实现线程安全，原理同Vector。</p>
<h2 id="ArrayList初始化分析"><a href="#ArrayList初始化分析" class="headerlink" title="ArrayList初始化分析"></a>ArrayList初始化分析</h2><p>鉴于源码内容较长，我们在这里先对ArrayList的几种构造方法进行解读，以下是JDK8中与构造方法相关的部分源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察一下上面的代码，首先是无参构造方法。我们看到，在该方法中，<code>elementData</code>被赋予了一个空数组，而这里是JDK6和之后的JDK之间一个比较大的区别。下面是JDK6的构造方法源码，我们可以发现在JDK6中的无参构造方法直接调用<code>this(10)</code>给数组容量初始化为10，而在那之后的版本中都是默认初始化为空数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于有参构造函数<code>ArrayList(int initialCapacity)</code>，只要初始化容量<code>initialCapacity</code>的值合适，就可以初始化适当大小的数组。<br>对于有参构造函数<code>ArrayList(Collection&lt;? extends E&gt; c)</code>，先将传入的集合转化为数组，然后将数组长度赋值给<code>size</code>，如果长度为0，则将数组初始化为空数组，否则判断数组类型是否是<code>Object[]</code>，如果不是就复制<code>elementData</code>中的元素转成<code>Object[]</code>数组给<code>elementData</code>。</p>
<h2 id="ArrayList添加元素"><a href="#ArrayList添加元素" class="headerlink" title="ArrayList添加元素"></a>ArrayList添加元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下默认的<code>add(E e)</code>添加元素的方法，我们看到在执行该方法时，会先调用<code>ensureCapacityInternal(size + 1)</code>检查添加一个元素之后是否需要扩容，然后将传入的元素添加到数组中，并增加数组的大小，最后返回true。接下来，我们要看看<code>ensureCapacityInternal(int minCapacity)</code>方法的具体源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察<code>ensureCapacityInternal(int minCapacity)</code>函数我们可以看到，ArrayList会首先判断<code>elementData</code>是不是默认的空数组，如果是的话，会比较<code>DEFAULT_CAPACITY</code>也就是10和<code>minCapacity</code>的大小，取较大的值赋给<code>minCapacity</code>。联系这里的源码我们可以知道，当一个ArrayList在无参构造方法不会初始化数组容量，只有在添加元素时，才会初始化数组容量，这里证实了我们前面说的和JDK6的不同之处。<br>接着往下看，我们看到这个方法又调用了<code>ensureExplicitCapacity(int minCapacity)</code>方法，我们继续往下看这个方法的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ensureExplicitCapacity(int minCapacity)</code>中首先我们需要知道<code>modCount</code>的作用，它是ArrayList的父类AbstractList中的一个成员变量，是用来记录修改次数的，因为增加元素是修改操作，所以<code>modCount++</code>。接着代码判断<code>minCapacity</code>的值有没有超过数组的容量，如果超过了就调用<code>grow(int minCapacity)</code>进行扩容，继续看后面的源码…看到这里，相信小伙伴们快看吐了，说实话，我写到这儿都快写吐了，这一层又一层的调用，真是老千层饼了…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的<code>grow(int minCapacity)</code>中，<code>oldCapacity</code>是原来数组的容量，<code>newCapacity</code>是<code>oldCapacity</code>的1.5倍，这里用到了位运算，不了解的同学可以先去学习一下位运算相关的知识。顺便提一下，在JDK6中，计算新容量大小的方法是<code>int newCapacity = (oldCapacity * 3)/2 + 1</code>。接着看源码，后面是对<code>newCapacity</code>范围做校验，如果比<code>minCapacity</code>小，则将<code>minCapacity</code>赋值给<code>minCapacity</code>，如果比<code>MAX_ARRAY_SIZE</code>大，就为数组赋一个超大容量。最后将数组元素复制到新的<code>elementData</code>中，也赋予新的容量<code>newCapacity</code>。</p>
<p>看完了默认的元素添加方法，我们再看一下在指定位置添加元素的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实和前面的默认添加元素方法没有太大区别，就是添加了一个下标校验防止越界。另外，还有将数组的<code>index</code>下标之后的元素拷贝到都向后移一位的操作，我们用图片解释一下这个操作。下图中，在下标为2的地方插入一个元素，那么从下标2开始的每一个元素都会向后移动，为插入的元素腾出一个位置。这也就解释了为什么ArrayList效率低的原因，这要是几亿、几十亿个数据都向后移动一位，那得多久啊…</p>
<p><img src="https://img-blog.csdnimg.cn/20200528180700953.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="arraycopy复制元素"></p>
<h2 id="ArrayList删除元素"><a href="#ArrayList删除元素" class="headerlink" title="ArrayList删除元素"></a>ArrayList删除元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了前面添加元素的操作，删除操作就容易多了，首先是对下标值的范围校验，然后又是对数组的复制操作<code>arraycopy</code>。继续画个图方便大家理解。所以同理，删除操作效率也很低。</p>
<p><img src="https://img-blog.csdnimg.cn/20200528183708568.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="arraycopy删除元素"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/101574379" target="_blank" rel="noopener">《吊打面试官》系列-ArrayList</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈Java容器-LinkedList</title>
    <url>/2020/06/05/%E8%B0%88%E8%B0%88Java%E5%AE%B9%E5%99%A8-LinkedList/</url>
    <content><![CDATA[<p>之前的文章中，我们谈到了ArrayList的源码分析，在今天的文章中，我们来看一种和ArrayList非常相似的Java容器——LinkedList。</p>
<a id="more"></a>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>谈到LinkedList，我们就不得不谈到它的底层数据结构——链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是LinkedList链表中节点的实现，我们来看一下每一个Node节点中存储一个值<code>item</code>，还有指向前后节点的<code>prev</code>和<code>next</code>，我们通过一张图来描述一下节点之间的关系。由下图我们可以知道LinkedList的底层实现是双向链表。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605155323943.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="Node节点之间的关系"></p>
<h2 id="成员变量和构造方法"><a href="#成员变量和构造方法" class="headerlink" title="成员变量和构造方法"></a>成员变量和构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很尴尬，构造方法什么都没有。就谈谈三个成员变量吧，说实话，我觉得从变量名大家都能看出来<code>size</code>是LinkedList的长度，<code>first</code>和<code>last</code>分别是LinkedList的头节点和尾节点。我们看一下调用了构造方法之后的运行时数据区的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605163431177.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="构造方法被调用后的运行时数据区"></p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>我们首先尝试添加写一个添加元素的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	list.add(<span class="string">"路人甲"</span>);</span><br><span class="line">	list.add(<span class="string">"路人乙"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add</code>方法中调用了一个<code>linkLast</code>方法进行真实的链表节点插入操作，我们尝试插入第一个元素，传入一个String类型的值“路人甲”，看一下<code>linkLast</code>进行了哪些操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于构造方法中没有对成员变量做任何操作，所以<code>last</code>的值是<code>null</code>，也就是说<code>l</code>被赋值为<code>null</code>。接着创建了一个新的节点，这个节点的<code>prev</code>指向<code>l</code>（也就是为空），<code>next</code>也为空。接着LinkedList的<code>last</code>指向了我们新创建的节点，然后我们需要判断<code>l</code>是否为空，这里是空值，所以我们将<code>first</code>也指向新节点。最后将链表长度加1，操作次数加1。</p>
<p><img src="https://img-blog.csdnimg.cn/2020060516385545.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="添加一个元素后的运行时数据区"></p>
<p>我们尝试再添加一个元素“路人乙”，由于插入了第一个元素，<code>last</code>指向了第一个元素，也就是<code>l</code>指向第一个元素。我们再创建一个新的node节点，<code>prev</code>指向<code>l</code>（也就是第一个节点），<code>next</code>仍然为空，再将<code>last</code>指向第二个节点。此时由于<code>l</code>已经不为空，所以判断语句会走else，也就是将第一个节点的<code>next</code>指向第二个节点，再次对链表长度和修改次数加1。看一下这时候内存区域的状态。</p>
<p><img src="https://img-blog.csdnimg.cn/20200605165029789.jpg?x-oss-process=type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMjczNDE3,size_16,color_FFFFFF,t_70#pic_center" alt="添加两个元素后的运行时数据区"></p>
<p>再次添加元素的操作基本和第二次添加元素差不多，就是引用指向节点和链表长度的变化，这里不再赘述。</p>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>我们来尝试一下删除元素“路人甲”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	list.add(<span class="string">"路人甲"</span>);</span><br><span class="line">	list.add(<span class="string">"路人乙"</span>);</span><br><span class="line">	list.remove(<span class="string">"路人甲"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看一下<code>remove</code>的源码部分，首先判断传入的元素是否为空，若为空则从链表头部开始查找节点值为空的元素，如果找到了就把进入<code>unlink</code>方法并返回true；若不为空就从链表头部开始查找节点值为传入的值的元素，如果找到了就把进入<code>unlink</code>方法并返回true；如果都没有找到传入的元素就返回false。由于传入的元素是“路人甲”，应该进入else循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看一下<code>unlink</code>方法的实现，代码有点长，希望大家耐心看完。由于我们删除的是“路人甲”，是链表的第一个元素，所以<code>prev</code>为空，<code>first</code>指向路人甲的下一个节点，而<code>next</code>是不为空的，所以路人乙的节点的<code>prev</code>指向一个空值，并将待删除元素的<code>next</code>置为空，元素的值也被置为空，链表长度减1，操作次数加1，返回删除元素的值。</p>
<p>那么如果删除的是“路人乙”呢？路人乙位于链表尾部，因此<code>next</code>为空，<code>prev</code>不为空，路人乙的前一个节点的<code>next</code>也就指向<code>null</code>，当前节点的<code>prev</code>也置为空了。接着把<code>last</code>置为空，并将待删除元素的值置为空，链表长度减1，操作次数加1，返回删除元素的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上讲了一些基础的添加与删除元素的操作，LinkedList还有一些其他的增/删元素的操作，比如在指定位置插入元素等，在指定位置操作元素就需要进行下标校验，原理上没有太大区别，大家可以自行阅读一下源码。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器与双亲委派模型</title>
    <url>/2020/07/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>之前说到类加载机制的相关原理，这次来谈谈类加载器以及双亲委派模型的概念。</p>
<a id="more"></a>

<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器是Java进行类加载的重要部分，但它的作用又不仅仅局限于进行类加载这么简单。对于两个类，如果要比较它们是否“相等”，首先要确认这两个类来自通过一个类加载器，否则谈论这两个类是否相等将毫无意义。<br>这里的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果。</p>
<p>类加载器一般被分为三种：启动类加载器、扩展类加载器、应用程序类加载器。</p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>启动类加载器与其他类加载器不同，它是由C++实现的类加载器，是在虚拟机内部的一部分，而其他加载器都是独立于Java虚拟机存在的。启动类加载器用来加载<code>%JAVA_HOME%\lib</code>目录或者被<code>-Xbootclasspath</code>参数指定的目录下的类库到虚拟机内存中，且要求类库文件名是Java虚拟机能够识别的，如rt.jar和tools.jar等。</p>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>扩展类加载器负责加载<code>%JAVA_HOME%\lib\ext</code>目录或者被<code>java.ext.dirs</code>系统变量所指定的目录下的类库。</p>
<h3 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h3><p>应用程序类加载器也被称为系统类加载器，负责加载用户类路径上的所有类库。如果用户没有自定义类加载器，那么默认使用该类加载器进行类加载。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="https://img-blog.csdnimg.cn/20200721173157703.png#pic_center" alt=""></p>
<p>双亲委派模型结构如上图所示，除了顶层的启动类加载器外，其他类加载器都有自己的父类加载器。下面的代码演示了类加载器的层次结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoaderParent</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"TestClassLoaderParent's classLoader is "</span></span><br><span class="line">				+ TestClassLoaderParent<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">		System.out.println(<span class="string">"The parent of testClassLoaderParent's classLoader is "</span> </span><br><span class="line">				+ TestClassLoaderParent<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">		System.out.println(<span class="string">"The grandparent of testClassLoaderParent's classLoader is "</span> </span><br><span class="line">				+ TestClassLoaderParent<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TestClassLoaderParent&#39;s classLoader is sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">The parent of testClassLoaderParent&#39;s classLoader is sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">The grandparent of testClassLoaderParent&#39;s classLoader is null</span><br></pre></td></tr></table></figure>

<p>最后输出的应用程序类加载器的祖父类加载器显示是null，这并不意味着这个祖父类加载器不存在，而是代表启动类加载器。</p>
<p>双亲委派模型的原理是当一个类加载器接收到类加载请求，这个类加载器不会自己尝试加载，而是让自己的父类加载器去完成，直到请求传送到最顶层的启动类加载器。如果父类加载器无法完成加载，则会让子类去加载。双亲委派模型的代码实现非常简单，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双亲委派模型的优点是越高层级的类加载器的优先级越高，这样无论加载任何类都会优先分配给最顶端的启动类加载器进行加载。例如如果我们需要加载java.lang.Object类，那么双亲委派机制可以保证启动类加载器每次从rt.jar中进行加载，而不是由别的类加载器加载，也确保了Java基础体系的安全性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>美团面试官：说说Redis的缓存雪崩、缓存穿透和缓存击穿</title>
    <url>/2020/10/07/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E8%AF%B4Redis%E7%9A%84%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    <content><![CDATA[<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>想象这样一个场景，当我们的Redis服务器中的缓存在某一段时间内大量失效或者Redis服务器瘫痪，用户的请求没有了缓存的拦截直接落在了数据库服务器上导致数据库服务器直接瘫痪，这就是我们今天要介绍的缓存雪崩。</p>
<a id="more"></a>

<p>对于缓存雪崩常见的解决方法主要有以下几种：</p>
<ul>
<li><p>随机设置key的过期时间。由于缓存雪崩的产生原因是短时间内key大量失效，我们可以将key的过期时间进行随机设置，防止这种情况发生。</p>
</li>
<li><p>如果是使用Redis集群部署，防止因为某个Redis服务器故障导致MySQL服务器瘫痪。</p>
</li>
<li><p>采用服务降级。所谓服务降级是指服务器压力骤增，选择性地关闭一些功能。比如双十一当天由于下单数过大，淘宝是禁止取消订单的，只能等到第二天才能取消订单，这就是常见的服务降级。</p>
</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透最常见的场景是黑客攻击。比如当我们访问一个网站的url为<code>XXXXX?id=1</code>，这是能够正常访问的页面。但是一些黑客通过使用一些本身不存在的id来频繁访问服务器，而我们的Redis里本身并没有存储这些不存在的key值，于是这些请求就直接打在数据库服务器上导致服务器瘫痪，这就是缓存穿透。</p>
<p>对于缓存穿透有一些常见的解决方法：</p>
<ul>
<li><p>对请求参数进行校验。对上面的这种情况来说，我们可以直接拦截不合法的id值，比如当id小于0时我们直接返回不存在。</p>
</li>
<li><p>在数据库中找不到数据时直接往Redis里写一个空值。比如当请求一个<code>id=-1</code>时数据库显然拿不到数据，可以直接将key为-1的value写一个空值到redis里，以后再有请求就能使用Redis查找了。</p>
</li>
<li><p>拉黑同一个频繁访问不存在数据的IP。</p>
</li>
<li><p>使用布隆过滤器。</p>
</li>
</ul>
<p>下面详细介绍一下布隆过滤器的原理。布隆过滤器采用一个bit数组，类似于下面这样，初始状态下布隆过滤器的bit数组都是值都为0。</p>
<p><img src="https://img-blog.csdnimg.cn/20201009194712681.png#pic_center" alt=""></p>
<p>我们还有一些hash函数，我们假设有一个字符串通过这些hash函数映射到不同的bit位上，如下所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20201009195314620.png#pic_center" alt=""></p>
<p>一个字符串通过不同hash函数映射到不同bit位后将这些bit位上的0改为1，以后再有相同字符串来时再通过这些hash函数映射到对应的bit位上只要看是否全为1即可。</p>
<p>布隆过滤器虽然很方便但却存在一些缺点。</p>
<p>能够保证找不到的数据一定不存在，但无法保证找到的数据一定存在。这句话听起来很拗口，简单地说，一个字符串通过多个hash函数映射到的bit位有0的那么一定不存在这个数据，但是一些字符串映射后得到的bit位有可能被其他数据置为1了，那么即使这个数据并不存在也有概率被判断为存在。</p>
<p>还有一个缺点是很难支持删除某个元素，因为当删除了某个元素（将bit位由1置为0时）有可能把别的数据的同一个bit位也给置为0了。</p>
<p>对于布隆过滤器来说，存储空间（bit数组）越大，误判率就会越低，数据越多，误判率就越高。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿和缓存雪崩非常类似但又不太相同，缓存击穿是指某些热点数据key值突然过期，导致这些请求直接打在数据库服务器上，于是服务器又瘫痪了。总的来说这两种情况都是由于key过期导致数据库崩溃的。</p>
<p>缓存击穿的解决方法主要包括下面几种：</p>
<ul>
<li><p>热点数据设置为永不过期。</p>
</li>
<li><p>使用zookeeper或者Redis实现互斥锁，等待第一个请求创建完缓存之后才允许后续请求继续访问。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>京东面试官：来说说synchronized和ReentrantLock的区别吧</title>
    <url>/2020/10/15/%E4%BA%AC%E4%B8%9C%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E6%9D%A5%E8%AF%B4%E8%AF%B4synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%A7/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
